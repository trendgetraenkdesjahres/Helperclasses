

/* FILE: ./APIClients/APIClient.php */

<?php

namespace PHP_Library\HTTPClient;

use \CurlHandle;
use PHP_Library\Error\Error;
use PHP_Library\Error\Warning;
use PHP_Library\Error\Notice;

class APIClient
{

    /**
     * Constructor and Initialization:
     *
     * This section of the code is responsible for setting up the foundational elements of the `APIClient` class. The constructor (`__construct`) initializes the API client, allowing developers to specify the API host and define whether JSON responses are expected. This pivotal step ensures that the client is ready for making HTTP requests and interacting with external APIs.
     *
     * Additionally, the `set_target_url` method offers the flexibility to define the target URL for API requests, including optional query parameters.
     */

    protected string $access_token;
    public string $host;
    public string|array $curl_response_body = '';
    public int $curl_response_code = 0;
    protected null|string $target_url = null;
    protected bool $talking_json = true;
    private CurlHandle $curl;
    private array $result_body_filters = [];
    private array $result_array_filters = [];

    /**
     * Constructor for the API client.
     *
     * @param false|string $host [optional] The hostname for the API client.
     * @param bool $talking_json [optional] If true, expects JSON responses.
     */
    public function __construct(false|string $host = false, bool $talking_json = true)
    {;
        if ($host) $this->host = (substr($host, -1) != '/') ? "$host/" : $host;
        $this->talking_json = $talking_json;
    }

    /**
     * Set the target URL for the API request.
     *
     * @param string $target The target URL or endpoint.
     * @param false|array $query_parameters [optional] An array of query parameters.
     *
     * @return APIClient Returns the current instance of the API client.
     */
    public function set_target_url(string $target = '', ?array $query_parameters = null): APIClient
    {
        if (is_int(strpos($target, '://'))) {
            $this->target_url = $target . ($query_parameters ? '?' . http_build_query(data: $query_parameters) : '');
            return $this;
        }
        if (isset($this) && isset($this->host)) {
            $this->target_url = $this->host . $target . ($query_parameters ? '?' . http_build_query(data: $query_parameters) : '');
            return $this;
        }
        Warning::trigger("Neither \$target ('$target') is valid nor \$this->host is set.");
        return $this;
    }

    /**
     * Perform a GET request.
     *
     * @param array $http_headers [optional] An array of HTTP headers.
     * @param array $curl_options [optional] Additional cURL options.
     * @param false|string $target_url [optional] The target URL for the request.
     *
     * @return APIClient Returns the current instance of the API client.
     */
    public function http_get(array $http_headers = [], array $curl_options = [], false|string $target_url = false): APIClient
    {
        if (!$target_url) {
            if (!$this->target_url) {
                $this->target_url = $this->host;
                Notice::trigger("No \$target_url is set up or given in \$this->target_url, will use '$this->host'");
            }
            $target_url = $this->target_url;
        }
        if ($this->curl = $this->prepare_curl(
            url: $target_url,
            http_headers: $http_headers,
            curl_options: $curl_options
        )) {
            try {
                $this->exec_curl($this->curl);
            } catch (Warning $e) {
                Warning::trigger($e->getMessage());
            }
        }
        return $this;
    }

    /**
     * Perform a POST request.
     *
     * @param false|array $post_fields [optional] An array of POST fields.
     * @param array $http_headers [optional] An array of HTTP headers.
     * @param array $curl_options [optional] Additional cURL options.
     * @param false|string $target_url [optional] The target URL for the request.
     *
     * @return APIClient Returns the current instance of the API client.
     */
    public function http_post(?array $post_fields = null, array $http_headers = [], array $curl_options = [], false|string $target_url = false): APIClient
    {
        if (!$target_url) {
            if (!$this->target_url) {
                $this->target_url = $this->host;
                Notice::trigger("No \$target_url is set up or given in \$this->target_url, will use '$this->host'");
            }
            $target_url = $this->target_url;
        }
        if ($this->curl = $this->prepare_curl(
            url: $target_url,
            http_headers: $http_headers,
            curl_options: $curl_options,
            post_fields: $post_fields
        )) {
            $this->exec_curl($this->curl);
        }
        return $this;
    }

    /**
     * cURL Handling and Execution:
     *
     * This section of the code is dedicated to the management of cURL requests and their execution. It encompasses methods responsible for preparing and executing cURL requests, handling potential errors, and processing the responses. These functions are vital for making HTTP requests and dealing with the intricacies of external APIs.
     *
     * - `prepare_curl`: Prepares the cURL handle with the necessary configurations for an HTTP request.
     * - `exec_curl`: Executes a cURL request, handles errors, and processes the response, ensuring that the data is retrieved and prepared for further use.
     */

    /**
     * Prepare the cURL handle for an HTTP request.
     *
     * @param string $url The URL for the request.
     * @param array $http_headers [optional] An array of HTTP headers.
     * @param array $curl_options [optional] Additional cURL options.
     * @param false|array $post_fields [optional] An array of POST fields.
     *
     * @return false|CurlHandle Returns the cURL handle or false on error.
     */
    private function prepare_curl(string $url, array $http_headers = [], array $curl_options = [], false|array $post_fields = false): false|CurlHandle
    {
        $curl  = curl_init();

        if ($this->talking_json) array_unshift($http_headers, 'Content-Type: application/json');

        if (isset($this->access_token)) array_unshift(
            $http_headers,
            'Content-Type: application/json',
            'Authorization: Bearer ' . $this->access_token
        );

        $sanitizing_http_headers = [];
        foreach ($http_headers as $field_name => $field_value) {
            if (is_string($field_name)) {
                $sanitizing_http_headers[$field_name] = $field_value;
                continue;
            }
            if ($field_pair = explode(":", $field_value, 2)) {
                $sanitizing_http_headers[$field_pair[0]] = $field_pair[1];
                continue;
            }
            Warning::trigger("'$field_value' is not a valid http header.");
        }
        $sanitized_http_headers = [];
        foreach ($sanitizing_http_headers as $field_name => $field_value) {
            array_push($sanitized_http_headers, trim($field_name) . ": " . trim($field_value));
        }
        if (is_array($post_fields)) {
            $curl_options = [
                CURLOPT_POST           => TRUE,
                CURLOPT_POSTFIELDS     => count($post_fields) > 1 ? json_encode($post_fields) : $post_fields[array_key_first($post_fields)]
            ] + (array) $curl_options;
        }
        $curl_options = array(
            CURLOPT_URL             => $url,
            CURLOPT_RETURNTRANSFER  => TRUE,
            CURLOPT_FOLLOWLOCATION  => TRUE,
            CURLOPT_ENCODING        => '',
            CURLOPT_MAXREDIRS       => 5,
            CURLOPT_TIMEOUT         => 5,
            CURLOPT_HTTP_VERSION    => CURL_HTTP_VERSION_1_1,
            CURLOPT_HTTPHEADER      => $sanitized_http_headers,
            CURLOPT_CONNECTTIMEOUT  => 5
        ) + (array) $curl_options;
        curl_setopt_array($curl, $curl_options);

        return $curl;
    }

    /**
     * Execute a cURL request, handle errors, and process the response.
     *
     * @param CurlHandle $curl_handle The cURL handle.
     *
     * @return mixed The response data or false on error.
     */

    private function exec_curl(CurlHandle $curl_handle): mixed
    {
        $curl_result = curl_exec($curl_handle);
        if ($curl_result === false) {
            $errno = curl_errno($curl_handle);
            $error = curl_error($curl_handle);
            Warning::trigger("Curl returned error $errno: $error\n");
            $this->curl_response_body = false;
            return false;
        }
        curl_close($curl_handle);

        $curl_result_http_code = (int) curl_getinfo($curl_handle, CURLINFO_HTTP_CODE);
        switch ($curl_result_http_code) {
            case $curl_result_http_code >= 500:
                throw new Warning($this->get_response_info(CURLINFO_EFFECTIVE_URL) . " returned $curl_result_http_code error");
                $this->curl_response_body = false;
                $this->curl_response_code = $curl_result_http_code;
                break;

            case $curl_result_http_code != 200:
                if ($this->talking_json) {
                    $response = json_decode(
                        json: $curl_result,
                        associative: true
                    );
                    if (!$response) {
                        break;
                    }

                    switch ($response) {
                        case isset($response['description']):
                            $description = "( {$response['description']} )";
                            break;

                        default:
                        case isset($response['error']):
                            $description = "( " . ($response['error']['message'] ?? $response['error_description'] ?? $response['error']) . ")";
                            break;
                    }
                }
                throw new Warning(
                    message: $this->get_response_info(CURLINFO_EFFECTIVE_URL) . " returned $curl_result_http_code error " . (isset($description) ? $description : '')
                );
                $this->curl_response_body = false;
                $this->curl_response_code = $curl_result_http_code;
                break;

            default:
                if (count($this->result_body_filters) > 0) {
                    foreach ($this->result_body_filters as $callable_filter) {
                        $curl_result = filter_var(
                            value: $curl_result,
                            filter: FILTER_CALLBACK,
                            options: ['options' => $callable_filter]
                        );
                    }
                }
                if ($this->talking_json) {
                    $json_response = json_decode(
                        json: $curl_result,
                        associative: true
                    );
                    $json_response = isset($json_response['result']) ? $json_response['result'] : $json_response;
                    if (!is_array($json_response)) {
                        throw new Warning("Response was not json. instead it was: '" . (string) $json_response . "'");
                    }
                    if (count($this->result_array_filters) > 0) {
                        foreach ($this->result_array_filters as $callable_filter) {
                            $json_response = call_user_func(
                                $callable_filter,
                                $json_response
                            );
                        }
                    }
                }
                $this->curl_response_body = isset($json_response) ? $json_response : $curl_result;
                $this->curl_response_code = $curl_result_http_code;
                break;
        }
        return $this;
    }

    /**
     * Response Processing and Filtering:
     *
     * This section of the code is dedicated to handling, processing, and filtering responses from HTTP requests. It includes methods for filtering and modifying both the response body and the resulting arrays after JSON conversion. These functions are essential for post-processing data retrieved from external APIs.
     *
     * - `add_result_body_filter`: Registers callback functions to filter the response body before JSON conversion.
     * - `add_result_array_filter`: Registers callback functions to filter the response array after JSON conversion.
     * - `get_response_body`: Retrieves the response body, ensuring it's obtained through an HTTP GET request and handling potential errors.
     * - `get_response_info`: Fetches information about the cURL request, allowing access to various cURL options and details.
     */

    /**
     * Register a callback to filter the response body before JSON conversion.
     *
     * @param callable $callable_filter The callback function for filtering.
     *
     * @return APIClient Returns the current instance of the API client.
     */
    public function add_result_body_filter(callable $callable_filter): APIClient
    {
        if (is_callable($callable_filter)) {
            array_push($this->result_body_filters, $callable_filter);
        } else {
            throw new Error("$callable_filter is not callable.");
        }
        return $this;
    }

    /**
     * Register a callback to filter the response array after JSON conversion.
     *
     * @param callable $callable_filter The callback function for filtering.
     *
     * @return APIClient Returns the current instance of the API client.
     */
    public function add_result_array_filter(callable $callable_filter): APIClient
    {
        if (is_callable($callable_filter)) {
            array_push($this->result_array_filters, $callable_filter);
        } else {
            throw new \Error("$callable_filter is not callable.");
        }
        return $this;
    }

    /**
     * Get the response body, making an HTTP request if needed.
     *
     * @return array|string|false The response data or false if an error occurred.
     */
    public function get_response_body(string $http_method = 'get'): array|string|false
    {
        if (!$this->curl_response_body) {
            switch ($http_method) {
                case 'get':
                    $this->http_get();
                    break;
                case 'post':
                    $this->http_post();
                    break;
                default:
                    throw new \Error("'{$http_method}' is not a http method.");
                    break;
            }
        }
        if ($this->curl_response_body) {
            return $this->curl_response_body;
        }
        throw new Warning("curl_response_body is emtpy.");
        return false;
    }

    /**
     * Get information about the cURL request.
     *
     * @param int $opt The cURL option to retrieve information for.
     *
     * @return mixed The requested information.
     */
    public function get_response_info(int $opt)
    {
        return curl_getinfo($this->curl, $opt);
    }
}


/* FILE: ./APIClients/SecureAPIClient.php */

<?php

namespace PHP_Library\HTTPClient;

use PHP_Library\Settings\Settings;

class SecureAPIClient extends APIClient
{
    public string $cookie_file;

    public function __construct(
        public string $user,
        public string $secret,
        public string $token_url,
        ?string $host = null,
        protected bool $talking_json = true
    ) {
        if ($host) $this->host = (substr($host, -1) != '/') ? "$host/" : $host;
        $this->access_token = $this->get_token($user,  $secret,  $token_url);
        $this->cookie_file = Settings::get('cookie_file');
    }

    private function get_token(string $user, string $secret, string $token_url)
    {
        $client = new APIClient();
        $response = $client->http_post(
            post_fields: ['grant_type=client_credentials'],
            http_headers: [
                'Authorization: Basic ' . base64_encode($user . ':' . $secret),
                'Content-Type: application/x-www-form-urlencoded',
            ],
            target_url: $token_url
        )->curl_response_body;

        if (isset($response['access_token'])) {
            return $response['access_token'];
        };
        PHP_Library\Warning::trigger("Could not receive access_token at $token_url for $user");
        return false;
    }
}


/* FILE: ./ClassTraits/SingletonPattern.php */

<?php

namespace PHP_Library\ClassTraits;

trait SingletonPattern
{
    protected static self $singleton_instance;

    abstract private function __construct();

    final protected static function init_singleton(): void
    {
        if (!isset(self::$singleton_instance)) {
            self::$singleton_instance = new self();
        }
    }

    public function __wakeup()
    {
        throw new \Exception("Cannot unserialize a singleton.");
    }
}


/* FILE: ./Model/Model.php */

<?php

namespace  PHP_Library\Model;

use  PHP_Library\Database\Database;
use  PHP_Library\Database\DatabaseTableInterface;
use  PHP_Library\Database\TableColumn;
use  PHP_Library\Debug\Debug;
use  PHP_Library\Notices\Warning;

abstract class Model
{
    private static bool $initialized = false;

    /**
     * Constructor for Models,
     * calls init_model(), which creates DB-Tables, like any other method that implements access_data()
     *
     * @return  void
     */
    public function __construct()
    {
        self::init_model();
    }

    /**
     * Get access to all the data of the class
     *
     * @return DatabaseTableInterface
     */
    private static function access_data(): DatabaseTableInterface
    {
        if (!self::$initialized) {
            self::init_model();
        }
        return Database::get_table(get_called_class());
    }

    final public static function init_model()
    {
        $class = get_called_class();
        if (!Database::table_exists($class)) {
            PHP_Library\Warning::trigger("'" . $class . "' has no table yet. will create one");
            self::create_table($class);
        }
        self::$initialized = true;
    }

    private static function create_table($class)
    {
        $columns = [];
        foreach ((new \ReflectionClass($class))->getProperties() as $property_reflection) {
            if (!$property_reflection->getType()->isBuiltin()) {
                throw new \Error("Model does not support custom types yet.");
            }
            if ($property_reflection->getType()->getName() == 'array') {
                throw new \Error("Model does not support arrays yet.");
            }
            if ($property_reflection->isPrivate()) {
                continue;
            }
            array_push($columns, new TableColumn(
                name: $property_reflection->getName(),
                type: $property_reflection->getType()->getName(),
                length: null,
                nullable: $property_reflection->getType()->allowsNull()
            ));
        }
        Database::create_table($class, ...$columns);
    }

    /**
     * Add in instance of this class
     *
     * @param array $property_value_pairs The data must represent the declared properties of the class.
     * @return DatabaseTableInterface
     */
    final static function add_instance(array $property_value_pairs): DatabaseTableInterface
    {
        return self::access_data()->add_row($property_value_pairs);
    }

    /**
     * Get's the value of a property from this class, where another value matches a property.
     * If there multiple matches, it will just return the first one
     *
     * @param string $property the property to return
     * @param string $property_value_pairs The conditions to check
     * @return mixed the value of the property
     */
    final static function get_value_where(string $property, string ...$property_value_pairs): mixed
    {
        return self::access_data()
            ->get_cell_where($property, ...$property_value_pairs);
    }

    final static function get_instance_where(string $property_value_pair): self
    {
        try {
            return self::array_to_instance(
                array: self::access_data()
                    ->get_any_row_where($property_value_pair)[0]
            );
        } catch (\Error $error) {
            throw new \Error("There is no '" . get_called_class() . "' where '$property_value_pair'");
        }
    }

    final static function get_instance(int $id): self
    {
        try {
            $array = self::access_data()
                ->get_row($id);
        } catch (\Error $error) {
            throw new \Error("There is no '" . get_called_class() . "' of id=$id");
        }
        return self::array_to_instance($array);
    }

    private static function array_to_instance(array $array): self
    {
        $reflection = new \ReflectionClass(get_called_class());
        $object = $reflection->newInstanceWithoutConstructor();
        foreach ($array as $property => $value) {
            if ($property === 'id') {
                continue;
            }
            if (!$reflection->hasProperty($property)) {
                throw new \Error("'" . get_called_class() . "' has no property named '$property'");
            }
            $property_reflection = $reflection->getProperty($property);
            $property_reflection->setAccessible(true);
            $property_reflection->setValue($object, $value);
        }
        return $object;
    }

    /**
     * Checks if an instance with a value of a property already exists
     *
     * @param string $property
     * @param string $value
     * @return bool
     */
    final static function has_instance_with_value(string $property, string $value): bool
    {
        if (self::access_data()->get_cell_where($property, "$property = '$value'")) {
            return true;
        }
        return false;
    }
}


/* FILE: ./Element/Fragment.php */

<?php

namespace PHP_Library\Element;

use DOMDocument;

/**
 * Class Fragment
 *
 * Represents an HTML DocumentFragment based on PHP DOMDocument for easier handling.
 */
class Fragment extends AbstractElement
{
    /**
     * Fragment constructor.
     *
     * @param string|Element ...$content The content, including sub-elements or strings.
     */
    final public function __construct(Element|string|null ...$content)
    {
        # init
        $this->dom = new DOMDocument();;

        # create fragment
        $this->node = $this->dom->createDocumentFragment();

        # add sub elements and strings
        $this->append_elements_to_node($content);
    }
}


/* FILE: ./Element/Ajax/ElementInteraction.php */

<?php

namespace PHP_Library\Element\Ajax;

use PHP_Library\Element\Element;
use PHP_Library\Router\Endpoint;

class ElementInteraction
{
    protected string $id;
    protected string $object_id;
    protected string $subject_id;
    protected string $trigger;
    protected string $endpoint;

    public function __construct(callable $new_content, Element $object, Element $subject, string $trigger_action)
    {
        $this->id = $this->get_unique_string();
        $this->trigger = $trigger_action;
        $this
            ->set_element_ids($object, $subject)
            ->set_endpoint($new_content);
    }

    public function __toString()
    {
        return (string) new AjaxScriptElement($this->object_id, $this->subject_id, $this->trigger, $this->endpoint, 'get');
    }

    protected function set_endpoint(callable $callback, string $prefix = '/ajax/elements/', string $method = 'get'): static
    {
        $path = $prefix . $this->id;
        $endpoint = new Endpoint(
            path: $path,
            http_method: $method,
            response_class: 'JSONResponse'
        );
        $this->endpoint = $path;
        $endpoint->add_callback($callback);
        return $this;
    }

    private function set_element_ids(Element &$object, Element &$subject): static
    {
        if (!$object->get_attribute('id')) {
            $object->set_attribute('id', bin2hex(random_bytes(4)));
        }
        $this->object_id = $object->get_attribute('id');
        if (!$subject->get_attribute('id')) {
            $subject->set_attribute('id', bin2hex(random_bytes(4)));
        }
        $this->subject_id = $subject->get_attribute('id');
        return $this;
    }

    private function get_unique_string(): string
    {
        $called_from = debug_backtrace(limit: 2)[1];
        return hash('md4', $called_from['file'] . $called_from['line']);
    }
}


/* FILE: ./Element/Ajax/AjaxScriptElement.php */

<?php

namespace PHP_Library\Element\Ajax;

use PHP_Library\Element\Element;

/**
 * - action after submit
 * - action after response (by code)
 */


class AjaxScriptElement
{
    private string $endpoint;

    protected array $code_for_response = [];

    public function __construct(protected string $object_id, protected string $subject_id, protected string $event, string $ajax_endpoint = "/ajax", protected string $method = 'post')
    {
        $this->endpoint = "window.location.origin + '{$ajax_endpoint}'";
        $this->code_for_response[200] = [
            "var object = document.getElementById('{$this->object_id}');",
            "object.innerText = JSON.parse(xhr.responseText);"
        ];
    }

    public function __toString()
    {
        $js_object_var =  "var subject = document.getElementById('{$this->subject_id}');";
        $js_object_event_listener = "subject.addEventListener('{$this->event}', function(event) {\n{$this->get_event_callback()}\n});";
        return new Element(
            'script',
            [],
            $js_object_var . "\n" . $js_object_event_listener
        );
    }

    protected function get_event_callback(): string
    {
        return implode("\n", [
            "event.preventDefault();",
            "var xhr = new XMLHttpRequest();",
            "xhr.open('{$this->method}', {$this->endpoint});",
            "xhr.setRequestHeader('Accept', 'application/json');",
            "xhr.onload = function() {\n{$this->get_onload_callback()}}",
            "xhr.send();"
        ]);
    }

    protected function get_onload_callback(): string
    {
        $string = '';
        foreach ($this->code_for_response as $response_code => $js_code_lines) {
            $if_statement = $string ? "else if (xhr.status === {$response_code})" : "if (xhr.status === {$response_code})";
            $string .= implode("\n", [
                $if_statement,
                "{\n{$this->get_js_code_for_response($response_code)}\n}"
            ]) . "\n";
        };
        return $string . "else {console.log(JSON.parse(xhr.responseText));}";
    }

    protected function get_js_code_for_response(int $code): string
    {
        if (!isset($this->code_for_response[$code])) {
            throw new \Error("No js-code for code '{$code}' is defined.");
        }
        return implode("\n", $this->code_for_response[$code]);
    }
}


/* FILE: ./Element/Element.php */

<?php

namespace PHP_Library\Element;

use DOMDocument;

/**
 * Class Element
 *
 * Represents an HTML element based on PHP DOMDocument for easier handling.
 */
class Element extends AbstractElement
{
    /**
     * @var \DOMElement The DOMElement instance.
     */
    protected $node;

    /**
     * Element constructor.
     *
     * @param string $name The name of the HTML element.
     * @param array $attributes An array of attributes for the HTML element.
     * @param string|Element ...$content The content, including sub-elements or strings.
     */
    final public function __construct(private string $name, private array $attributes = [], Element|string ...$content)
    {
        # init
        $this->dom = new DOMDocument();

        # create element
        $this->node = $this->dom->createElement($this->name);

        # set attributes
        foreach ($this->attributes as $attribute => $value) {
            if (is_int($attribute)) {
                $attribute = $value;
            }
            if (isset($value)) $this->node->setAttribute($attribute, $value);
        }

        # add sub elements and strings
        $this->append_elements_to_node($content);
    }

    public function get_attribute(string $attribute): string
    {
        return $this->node->getAttribute($attribute);
    }

    public function set_attribute(string $attribute, ?string $value): self
    {
        $this->node->setAttribute($attribute, $value);
        return $this;
    }

    public static function from_string(string $html): static
    {
        $dom = new DOMDocument();
        $dom->loadXML($html);
        $dom_node = $dom->importNode($dom->documentElement, true);
        $element = new Element($dom_node->tagName);
        $element->node = $dom_node;
        return $element;
    }
}


/* FILE: ./Element/AbstractElement.php */

<?php

namespace PHP_Library\Element;


/**
 * Class AbstractElement
 *
 * Represents an abstract element based on PHP DOMDocument for easier handling.
 */
abstract class AbstractElement
{
    /**
     * @var \DOMDocument The DOMDocument instance.
     */
    protected \DOMDocument $dom;

    /**
     * @var \DOMNode The DOMNode instance.
     */
    protected $node;

    /**
     * Appends sub-elements or strings to the current node.
     *
     * @param array $content An array of content, including sub-elements or strings.
     * @return AbstractElement The current instance of AbstractElement.
     */
    protected function append_elements_to_node(array $content): AbstractElement
    {
        # append content, juggle sub-elements to strings.
        foreach ($content as $content) {
            if ($content instanceof AbstractElement) {
                $child_element = $this->dom->importNode($content->node, true);
                $this->node->appendChild($child_element);
            } elseif (is_string($content)) {
                $text_node = $this->dom->createTextNode($content);
                $this->node->appendChild($text_node);
            }
        }
        return $this;
    }

    public function append_child(AbstractElement ...$child): AbstractElement
    {
        foreach ($child as $child) {
            $child_element = $this->dom->importNode($child->node, true);
            $this->node->appendChild($child_element);
        }
        return $this;
    }

    /**
     * Converts the element to a string representation.
     *
     * @return string The string representation of the element.
     */
    public function __toString(): string
    {
        # return as string
        return $this->dom->saveXML($this->node);
    }
}


/* FILE: ./Error/FormatTrait.php */

<?php

namespace PHP_Library\Error;

trait FormatTrait
{
    public function __toString(): string
    {
        return self::format_message($this->message);
    }

    protected static function format_message($message, ?int $code = null)
    {
        $code = is_int($code) ? "({$code})" : '';
        $class_name = (new \ReflectionClass(get_called_class()))->getShortName();
        $function_trace = self::get_parent_functions(trace_limit: 3);
        return "{$class_name}{$code} [{$function_trace}]: {$message}";
    }

    /**
     * Get the string of the calling function.
     *
     * @param int $trace_limit The number of call stack levels to trace.
     *
     * @return string The name of the calling function.
     */
    protected static function get_parent_functions(int $trace_limit): string
    {
        $trace = array_reverse(debug_backtrace(
            options: 2,
            limit: $trace_limit
        ));
        $function_name = '';
        $open_brackets = 0;
        foreach ($trace as $caller) {
            if (isset($caller['type'])) {
                if (is_subclass_of(get_called_class(), $caller['class']) || get_called_class() === __CLASS__) {
                    continue;
                }
                $open_brackets++;
                $function_name .= $caller['class'] . $caller['type'] . $caller['function'] . "(";
            } elseif (!$caller) {
                $function_name .= '> ';
            } else {
                $open_brackets++;
                $function_name .= $caller['function'] . "(";
            }
        }
        $function_name .= str_repeat(string: ")", times: $open_brackets);
        $function_name = $function_name ? $function_name : 'MAIN';
        return $function_name;
    }

    /**
     * Get the file and line number where the function is called from.
     *
     * @param int $trace_level The call stack level to trace.
     *
     * @return string The file and line number of the calling function.
     */
    protected static function get_parent_file(int $trace_level): string
    {
        $trace = debug_backtrace(
            options: 2,
            limit: $trace_level
        )[$trace_level - 1];
        $file = str_replace(
            search: getcwd() . "/",
            replace: '',
            subject: $trace['file']
        );
        return "$file:{$trace['line']}";
    }
}


/* FILE: ./Error/Stop.php */

<?php

namespace PHP_Library\Error;

class Stop extends Error {}


/* FILE: ./Error/Notice.php */

<?php

namespace PHP_Library\Error;

class Notice
{

    use FormatTrait;

    /**
     * Notice class extends the base \Exception class and handles custom PHP_Library\Notices.
     */
    private static $initialized = false;

    protected static $user_errno = E_USER_NOTICE;
    protected static $errno = E_NOTICE;

    /**
     * Constructor for the Notice class.
     *
     * @param string $message The message to be associated with this notice.
     */
    public function __construct(public string $message)
    {
        if (!self::$initialized) {
            self::$initialized = $this::initialize();
        }
        trigger_error(
            message: $this->message,
            error_level: self::$user_errno
        );
    }

    public static function if(bool $condition, string $message)
    {
        if ($condition) {
            new self($message);
        }
    }

    /**
     * Trigger a custom notice with a message and additional information.
     *
     * @param string $message The notice message to display.
     */
    public static function trigger(string $message): void
    {
        new self($message);
    }

    /**
     * Initialize the custom error handler for handling user PHP_Library\Notices and PHP_Library\Warnings.
     * This method sets up a custom error handler for E_USER_WARNING and E_USER_NOTICE.
     */
    private static function initialize(): bool
    {
        set_error_handler(
            function ($errno, $message, $file, $line) {
                if ($errno === self::$errno || $errno === self::$user_errno) {
                    echo self::format_message($message) . "\n";
                    return true;
                }
                return false;
            }
        );
        set_exception_handler(
            function ($exception) {
                if (get_class($exception) === __CLASS__) {
                    echo self::format_message($exception->message) . "\n";
                    return true;
                }
                return false;
            }
        );
        return true;
    }
}


/* FILE: ./Error/Warning.php */

<?php

namespace PHP_Library\Error;

class Warning extends Notice
{
    protected static $user_errno = E_USER_WARNING;
    protected static $errno = E_WARNING;
}


/* FILE: ./Error/Error.php */

<?php

namespace PHP_Library\Error;

class Error extends \Error
{
    use FormatTrait;

    private static bool $initialized = false;

    protected static int $exit_code = 1;

    protected string $file;
    protected int $line;

    protected static $errno = E_ERROR;

    public static function if(bool $condition, string $message, int $code = 0)
    {
        if ($condition) {
            throw new self($message, $code);
        }
    }

    public function __construct(string $message = "", int $code = 0, \Throwable|null $previous = null)
    {
        parent::__construct($message, $code, $previous);
        self::initialize();
        if ($trace = $this->getTrace()) {
            $trace = @end($trace);
            if (isset($trace['file'])) {
                $this->file = $trace['file'];
                $this->line = $trace['line'];
            }
        }
    }

    /**
     * Initialize the custom error handler for handling user PHP_Library\Notices and PHP_Library\Warnings.
     * This method sets up a custom error handler for E_USER_WARNING and E_USER_NOTICE.
     */
    private static function initialize(): bool
    {
        if (static::$initialized) {
            return true;
        }
        set_error_handler(
            function ($errno, $message, $file, $line) {
                // Only handle errors matching self::$errno
                if ($errno === self::$errno) {
                    echo self::format_message($message, $errno) . " in {$file}:{$line}\n";
                } else {
                    // Allow other handlers to process this error
                    return false;
                }
            }
        );
        set_exception_handler(
            function ($exception) {
                // Ensure we're handling only instances of this Error class
                if ($exception instanceof static) {
                    print self::format_message($exception->getMessage(), $exception->getCode()) .
                        " in {$exception->getFile()}:{$exception->getLine()}\n";
                } else {
                    return false;
                }
            }
        );
        static::$initialized = true;
        return true;
    }
}


/* FILE: ./Debug/Debug.php */

<?php

namespace  PHP_Library\Debug;

use  PHP_Library\Types\StringType;
use  PHP_Library\Types\AbstractType;

class Debug
{
    private string $method;
    private string $location;

    private string $expression_type;
    private mixed  $expression_value;

    public function __construct(mixed $expression)
    {
        $caller = debug_backtrace(limit: 2)[1];
        $caller_location = str_replace(
            search: getcwd() . "/",
            replace: '',
            subject: $caller['file']
        );
        $class = (new \ReflectionClass($caller['class']))->getShortName();
        $this->method   = $class . $caller['type'] . $caller['function'];
        $this->location = $caller_location . ":{$caller['line']}";

        $this->expression_type      = ($type = gettype($expression)) == 'object' ? get_class($expression) : $type;
        $this->expression_value     = $expression;
    }

    public static function die(mixed $var = null): void
    {
        $debugger = new Debug($var);
        $debugger->print_expr_info();
        die();
    }

    public static function var(mixed $var = null): Debug
    {
        $debugger = new Debug($var);
        $debugger->print_expr_info();
        return $debugger;
    }

    private function print_expr_info(): void
    {
        $GLOBALS['DEBUG_PRINT'] = true;
        if (php_sapi_name() === 'cli') {
            $this->print_cli_var();
        } else {
            $this->print_html_var();
        }
        unset($GLOBALS['DEBUG_PRINT']);
    }

    private function print_cli_var(): void
    {
        $var_content = AbstractType::construct($this->expression_value);
        $title = new StringType("$this->method($this->expression_type)");
        if ($this->expression_type == 'string') {
            $expression = new StringType((string)$var_content);
            $string_length = $expression->get_length();
            $expression->replace(PHP_EOL, '¶' . PHP_EOL)->word_wrap(80)->surround('`')->append("($string_length)");
        } else {
            $expression = new StringType((string) $var_content);
        }
        $title->format_bold();
        $string = new StringType("$title $this->location\n$expression");
        print $string->box_around_string(2);
    }

    private function print_html_var(): void
    {
        $var_content = AbstractType::construct($this->expression_value);
        $title = new StringType("$this->method(<code>$this->expression_type</code>)");
        if ($this->expression_type == 'string') {
            $expression = new StringType((string)$var_content);
            $string_length = $expression->get_length();
            $expression->replace(PHP_EOL, '¶' . PHP_EOL)->word_wrap(80)->surround('`')->append("($string_length)");
        } else {
            $expression = new StringType((string) $var_content);
        }
        $css_style = "
        details {
            position: sticky;
            width: max-content;
            padding: 0.5em 1em;
        }

        details summary > * {
            display: inline-block;
        }

        details summary {
            cursor: pointer;
        }

        details figure {
            background-color: rgba(0,0,0, 0.05);
            margin: 0;
            padding: 0.5em;
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 500ms;
        }

        details[open] figure {
            grid-template-rows: 1fr;
        }

        details figure pre {
            overflow: hidden;
            margin: 0;
        }
        ";
        print "<style>$css_style</style><details><summary><div>$this->location<b> $title</b></div></summary><figure><pre>$expression</pre><figcaption><small></small></figcaption></figure></details>";
    }
}


/* FILE: ./include_me.php */

<?php

use PHP_Library\Autoloader;

include 'Autoloader.php';

// Start the autoloader by creating a new ClassAutoloader instance.
// This sets up autoloading for both PHP_Library and other classes found in the parent directory, guessing it's the includes directory with all the classes.
new Autoloader(dirname(__FILE__, 2));


/* FILE: ./Database/FileDatabase.php */

<?php

namespace  PHP_Library\Database;

use PHP_Library\Database\Error\DatabaseError;
use PHP_Library\Database\FileDatabaseAggregate\FileDatabaseAggregate;
use PHP_Library\Database\SQLanguage\Statement\AbstractStatement;
use PHP_Library\Database\Table\Column\Column;
use PHP_Library\Database\Table\Column\PrimaryAutoIncrementKey;
use PHP_Library\Database\Table\FileTable;
use PHP_Library\Error\Warning;
use  PHP_Library\Settings\Settings;
use  PHP_Library\System\FileHandle;
use ReflectionClass;

/**
 * FileStorage is a class that handles data storage using files.
 */
class FileDatabase extends Database
{
    use FileDatabaseAggregate;

    private static FileHandle $file;

    protected static int $last_insert_id;

    public static mixed $data = null;
    public static mixed $query_result = [];

    public function __destruct()
    {
        self::$file->close_file();
    }

    /**
     * Initialize the file storage.
     *
     * @return bool Returns true if initialization is successful, false otherwise.
     */
    public static function initalize(): bool
    {
        Settings::register('Database/file_name');
        $path = Settings::get('Database/file_name');
        if (!str_starts_with($path, DIRECTORY_SEPARATOR)) {
            $path = getcwd() . '/' . $path;
        }
        self::$file = new FileHandle($path);
        try {
            self::$file
                ->create_file(force: false)
                ->open_file()
                ->close_file();
            self::$data = self::$file->get_memory();
            return true;
        } catch (\Throwable $t) {
            DatabaseError::trigger("Could not initalize File-Database connection: " . $t->getMessage());
        }
        register_shutdown_function(function () {
            self::$file->close_file();
        });
    }

    /**
     * Get a table instance by name.
     *
     * @param string $table_name The name of the table.
     * @return FileTable The table instance.
     */
    public static function get_table(string $table_name): FileTable
    {
        return new FileTable($table_name, false);
    }

    public static function last_insert_id(): int|false
    {
        return isset(static::$last_insert_id) ? static::$last_insert_id : false;
    }
    /**
     * Create a table with the given name and columns.
     *
     * @param string $table The name of the table.
     * @param Column ...$columns The columns to create.
     * @return bool Returns true if the table is created, false if it already exists.
     */
    public static function create_table(string $table, Column ...$columns): bool
    {
        if (self::$data) {
            if (key_exists($table, self::$data)) {
                Warning::trigger("'$table' already exists. Not created.");
                return false;
            }
        } else {
            self::$data = [];
        }
        // check primary Key: there has be exactly one and in first place
        $primary_key_columns = [];
        foreach ($columns as $i => $column) {
            if ($column::$is_primary_key) {
                $primary_key_columns[] = $i;
            }
        }
        if (empty($primary_key_columns)) {
            $primary_key = new PrimaryAutoIncrementKey(FileTable::$default_id_column_name);
            array_unshift($columns, $primary_key);
        } else if (count($primary_key_columns) === 1) {
            $primary_key = $columns[$primary_key_columns[0]];
        } else {
            throw new DatabaseError("A table can have only ONE primary key.");
        }

        // build table
        self::$data[$table] = [];
        self::$data['%tables'][$table]['%primary_key'] = $primary_key->name;
        foreach ($columns as $column) {
            self::$data[$table][$column->name] = [];
            self::$data['%tables'][$table][$column->name] =
                [
                    'type' => $column->type,
                    'nullable' => $column->nullable,
                    'timestamp' => $column->timestamp,
                    'auto_increment' => isset($column::$auto_increment) ? $column::$auto_increment : false
                ];
        }
        self::dump_data_in_file();
        return true;
    }

    /**
     * Check if a table exists.
     *
     * @param string $table The table name.
     * @return bool Returns true if the element exists, false otherwise.
     */
    public static function table_exists(string $table, ?string $throwable = null): bool
    {
        if (!self::$data) {
            if ($throwable) {
                throw new $throwable("Database is empty.");
            }
            return false;
        }
        if (!key_exists($table, self::$data)) {
            if ($throwable) {
                throw new $throwable("Table '$table' does not exist");
            }
            return false;
        }
        return true;
    }

    /**
     * Get the queried data.
     *
     * @return mixed The queried data.
     */
    protected static function get_queried_data(bool $clean_array = false): mixed
    {
        if ($clean_array) {
            return static::clean_array(self::$query_result);
        }
        return self::$query_result;
    }

    protected static function execute_query(AbstractStatement $sql_statement): bool
    {
        $command = strtoupper((new ReflectionClass($sql_statement))->getShortName());
        switch ($command) {
            case 'DELETE':
                static::$data = static::$file->open_file('r+')
                    ->get_memory();
                static::$query_result = static::execute_delete($sql_statement);
                static::$file->write_file(static::$data)
                    ->close_file();
                break;

            case 'INSERT':
                static::$data = static::$file->open_file('r+')
                    ->get_memory();
                $last_insert_id = static::execute_insert($sql_statement);
                if (! $last_insert_id) {
                    static::$query_result = false;
                } else {
                    static::$query_result = true;
                    static::$last_insert_id = $last_insert_id;
                }
                static::$file->write_file(static::$data)
                    ->close_file();
                break;

            case 'SELECT':
                static::$data = static::$file->open_file('r')
                    ->get_memory();
                static::$query_result = static::execute_select($sql_statement);
                static::$file->close_file();
                break;

            case 'UPDATE':
                static::$data = static::$file->open_file('r+')
                    ->get_memory();
                static::$query_result = static::execute_update($sql_statement);
                static::$file->write_file(static::$data)
                    ->close_file();
                break;

            default:
                DatabaseError::trigger("Executing '$command'-queries is not implemented.");
        }
        return (bool) static::$query_result;
    }

    private static function get_file(): FileHandle
    {
        if (!isset(self::$file)) {
            self::initalize();
        }
        return self::$file;
    }

    private static function dump_data_in_file(): void
    {
        self::get_file()
            ->open_file('r+', false)
            ->write_file(self::$data)
            ->close_file();
    }
}


/* FILE: ./Database/Error/DatabaseError.php */

<?php

namespace PHP_Library\Database\Error;

class DatabaseError extends \PHP_Library\Error\Error
{
    public static DatabaseError $last_error;

    public static function trigger(string $message = "", int $code = 0, bool $fatal = false)
    {
        if ($fatal) {
            throw new static($message, $code);
        }
        static::$last_error = new static($message, $code);
    }
}


/* FILE: ./Database/Database.php */

<?php

namespace  PHP_Library\Database;

use PHP_Library\Database\Error\DatabaseError;
use PHP_Library\Database\SQLanguage\Statement\AbstractStatement;
use PHP_Library\Database\Table\Column\Column;
use PHP_Library\Database\Table\DataTable;
use PHP_Library\Settings\Settings;
use ReflectionClass;

/**
 * Database is a place for tables stored in Databases or Files
 */
abstract class Database
{
    /**
     * Holds the initialized storage instance implementation. It's can not be this abstract class Database, that will not work.
     *
     * @var Database|null
     */
    private static ?Database $instance = null;

    /**
     * Initialize the database connection.
     *
     * @return bool Returns true if initialization is successful, false otherwise.
     */
    abstract protected static function initalize(): bool;

    abstract public static function last_insert_id(): int|false;

    /**
     * Get queried data.
     *
     * @param bool $clean_array if the result is an array, and has just one element, it will return this element (recursivly).
     * @return mixed The queried data.
     */
    abstract protected static function get_queried_data(bool $clean_array = false): mixed;

    /**
     * Internal implementation of the execution of a SQL Statement
     * @param AbstractStatement $sql_statement The SQL statement to execute.
     * @return bool success.
     */
    abstract protected static function execute_query(AbstractStatement $sql_statement): bool;

    /**
     * Database is a place for tables stored in Databases or Files.
     * It will be constructed by setting for `[Database]/database_name` or `[Database]/file_name` found in a `settings.ini`-file.
     * If using the FileDatabase, the location 'Database/file_name' needs to be writable by the php-server.
     */
    final public function __construct()
    {
        static::initalize();
    }

    /**
     * Execute SQL Statement.
     * Get the results with `get_queried_data()`
     * @param AbstractStatement $sql_statement The SQL statement to execute.
     * @return bool success.
     */
    final public static function query(AbstractStatement $sql_statement): bool
    {
        if (static::get_type() === __CLASS__) {
            DatabaseError::trigger("Database is not initiated.", fatal: true);
        }
        return self::get_instance()::execute_query($sql_statement);
    }

    /**
     * Get recent queried data.
     *
     * @param bool $clean_array if the result is an array, and has just one element, it will return this element (recursivly).
     * @return mixed The queried data.
     */
    public static function get_query_result(bool $clean_array = false): mixed
    {
        return self::get_instance()::get_queried_data($clean_array);
    }

    /**
     * Get a table instance by name.
     *
     * @param string $name The name of the table.
     * @return DataTable The table instance.
     */
    public static function get_table(string $name): DataTable
    {
        return self::get_instance()::get_table($name);
    }

    public static function get_last_insert_id(): int|false
    {
        return self::get_instance()::last_insert_id();
    }

    /**
     * Create a table instance based on the specified name and columns.
     *
     * @param string $name The name of the table.
     * @param Column ...$columns Variable-length list of TableColumn objects representing table columns.
     * @return bool Success.
     */
    public static function create_table(string $name, Column ...$columns): bool
    {
        return self::get_instance()::create_table($name, ...$columns);
    }

    public static function table_exists(string $name): bool
    {
        return self::get_instance()::table_exists($name);
    }

    public static function get_type(): string
    {
        return (new ReflectionClass(self::get_instance()))->getShortName();
    }

    public static function get_last_error(): DatabaseError|null
    {
        return isset(DatabaseError::$last_error) ? DatabaseError::$last_error : null;
    }

    /**
     * Factory method to get or initialize the appropriate storage instance.
     *
     * @return Database The initialized storage instance.
     * @throws DatabaseError If no suitable configuration for Filebased or DBbased setting is found.
     */
    protected static function get_instance(): static
    {
        if (self::$instance === null) {
            // Check settings to decide the storage type
            if (Settings::get('Database/database_name')) {
                self::$instance = new SQLDatabase();
            } elseif (Settings::get('Database/file_name')) {
                self::$instance = new FileDatabase();
            } else {
                DatabaseError::trigger("No setting for 'Database/database_name' or 'Database/file_name' found in settings-file.", fatal: true);
            }
        }
        return self::$instance;
    }

    protected static function clean_array(array $array): mixed
    {
        $count = count($array);
        switch ($count) {
            case 0:
                return [];
            case 1:
                $value = $array[array_key_first($array)];
                if (is_array($value)) {
                    return static::clean_array($value);
                }
                return $value;
            default:
                return $array;
        }
    }
}


/* FILE: ./Database/Table/DataTable.php */

<?php

namespace  PHP_Library\Database\Table;

use PHP_Library\Database\Database;
use PHP_Library\Database\Error\DatabaseError;
use PHP_Library\Database\SQLanguage\Statement\Delete;
use PHP_Library\Database\SQLanguage\Statement\Insert;
use PHP_Library\Database\SQLanguage\Statement\Select;
use PHP_Library\Database\SQLanguage\Statement\Update;
use PHP_Library\Settings\Settings;

abstract class DataTable
{
    /**
     * Holds the initialized table instance implementation. It can not be this abstract class DataTable, that will not work.
     *
     * @var DataTable|null
     */
    private static ?DataTable $instance = null;

    /**
     * The name of this table.
     *
     * @var string
     */
    public string $name;

    abstract public function select_count(): int;

    /**
     * Create a DB Statement for this table. To query it on the current DB, call `execute()`.
     * Build Statement with `where()`.
     *
     * @return Delete Statement
     **/
    public function delete(): Delete
    {
        return new Delete($this->name);
    }

    /**
     * Delete a row of the table directly (will be executed directly).
     * Values need to be in order of the columns.
     *
     * @param int $id The ID of the row.
     * @return bool Success.
     */
    public function delete_row(int $id): bool
    {
        $this
            ->delete()
            ->where_equals('id', $id)
            ->execute();
        return (bool) Database::get_query_result();
    }

    /**
     * Create a DB Statement for this table. To query it on the current DB, call `execute()`.
     * Build Statement with `values()`.
     *
     * @return Insert Statement
     **/
    public function insert(string ...$columns): Insert
    {
        return new Insert($this->name, ...$columns);
    }

    /**
     * Inserts a new row into the table directly (will be executed directly).
     * Values need to be in order of the columns.
     *
     * @param string|int|float $values Values in the order of the columns.
     * @return int Count of inserted cells.
     */
    public function insert_row(string|int|float ...$values): int
    {
        $this
            ->insert()
            ->values(...$values)
            ->execute();
        return (int) Database::get_query_result();
    }

    /**
     * Alias for `insert_row()`
     *
     * @param string|int|float $values Values in the order of the columns.
     * @return int Count of inserted cells.
     */
    public function add_row(string|int|float ...$values): int
    {
        return $this->insert_row(...$values);
    }

    /**
     * Create a DB Statement for this table. To query it on the current DB, call `execute()`.
     * Build Statement with `where()`.
     *
     * @return Select Statement
     **/
    public function select(string $column = '*', string ...$more_columns): Select
    {
        return new Select($this->name, $column, ...$more_columns);
    }

    /**
     * Select and get a row from the table by its ID directly (will be executed directly).
     *
     * @param int $id The ID of the row.
     * @return array The row data.
     */
    public function select_row(int $id): array
    {
        $this
            ->select()
            ->where_equals('id', $id)
            ->execute();
        return Database::get_query_result()[0];
    }

    /**
     * Alias for `select_row()`
     *
     * @param int $id The ID of the row.
     * @return array The row data.
     */
    public function get_row(int $id): array
    {
        return $this->select_row($id);
    }

    /**
     * Create a DB Statement for this table. To query it on the current DB, call `execute()`.
     * Build Statement with `where()` and `set()`.
     *
     * @return Update Statement
     **/
    public function update(): Update
    {
        return new Update($this->name);
    }

    /**
     * Update a row from the table by its ID.
     *
     * @param int $id The ID of the row.
     * @param array $cells Assotiative array with cells and values.
     * @return array The row data.
     */
    public function update_row(int $id, array $cells): array
    {
        $update = $this->update()
            ->where_equals('id', $id);
        foreach ($cells as $column_name => $value) {
            $update->set($column_name, $value);
        }
        $update->execute();
        return Database::get_query_result();
    }

    final public function __construct(string $name)
    {
        $this->name = $name;
    }

    /**
     * Get the name of the table.
     *
     * @return string The name.
     */
    public function get_name(): string
    {
        return $this->name;
    }

    /**
     * Factory method to get or initialize the appropriate storage instance.
     *
     * @return static The initialized storage instance.
     * @throws \Error If no suitable configuration for Filebased or DBbased setting is found.
     */
    protected static function get_instance(string $name): static
    {
        if (self::$instance === null) {
            // Check settings to decide the storage type
            if (Settings::get('Database/database_name')) {
                self::$instance = new SQLTable($name);
            } elseif (Settings::get('Database/file_name')) {
                self::$instance = new FileTable($name);
            } else {
                throw new DatabaseError("No setting for 'Database/database_name' or 'Database/file_name' found in settings-file.");
            }
        }
        return self::$instance;
    }
}


/* FILE: ./Database/Table/SQLTable.php */

<?php

namespace  PHP_Library\Database\Table;

class SQLTable extends DataTable {}


/* FILE: ./Database/Table/FileTable.php */

<?php

namespace  PHP_Library\Database\Table;

use PHP_Library\Database\FileDatabase;

class FileTable extends DataTable
{
    /**
     * secret row id column name
     * @var string
     */
    static public string $default_id_column_name = 'rowid';

    public function select_count(): int
    {
        return count(
            FileDatabase::$data[$this->name][array_key_first(FileDatabase::$data[$this->name])]
        );
    }
}


/* FILE: ./Database/Table/Column/PrimaryKey.php */

<?php

namespace PHP_Library\Database\Table\Column;

// AUTO INCREMENT
class PrimaryKey extends Column
{
    public static bool $is_primary_key = true;

    public function __construct(string $name, string $type, ?int $length = null)
    {
        parent::__construct($name, $type, $length);
    }
}


/* FILE: ./Database/Table/Column/PrimaryAutoIncrementKey.php */

<?php

namespace PHP_Library\Database\Table\Column;

// AUTO INCREMENT
class PrimaryAutoIncrementKey extends PrimaryKey
{
    public static bool $auto_increment = true;

    public function __construct(string $name)
    {
        parent::__construct($name, 'int');
    }
}


/* FILE: ./Database/Table/Column/Column.php */

<?php

namespace PHP_Library\Database\Table\Column;

use PHP_Library\Database\Error\DatabaseError;
use PHP_Library\Database\SQLanguage\Error\SQLanguageError;
use PHP_Library\Database\SQLanguage\SyntaxCheck;

/**
 * TableColumn represents a table column with its properties.
 */
class Column
{
    public string $name;
    public static bool $auto_increment = false;
    public static bool $is_primary_key = false;

    /**
     * Constructor for TableColumn.
     *
     * @param string $name The column name.
     * @param string $type The data type of the column.
     * @param int|null $length The maximum length of the column (if applicable).
     * @param bool $nullable Whether the column is nullable.
     * @param bool $timestamp Whether the column is a timestamp.
     */
    public function __construct(
        string $name,
        public string $type = 'string',
        public ?int $length = null,
        public bool $nullable = false,
        public bool $timestamp = false
    ) {
        if (! SyntaxCheck::is_field_name($name)) {
            throw new DatabaseError("{$name} is not a column name.");
        }
        $this->name = trim($name);
        // TODO apply sql lang check on type!!
    }
}


/* FILE: ./Database/SQLanguage/Error/SQLanguageError.php */

<?php

namespace PHP_Library\Database\SQLanguage\Error;

class SQLanguageError extends \PHP_Library\Error\Error {}


/* FILE: ./Database/SQLanguage/Statement/Clause/WhereClauseTrait.php */

<?php

namespace PHP_Library\Database\SQLanguage\Statement\Clause;

use PHP_Library\Database\Database;
use PHP_Library\Database\SQLanguage\Error\SQLanguageError;
use PHP_Library\Database\SQLanguage\SyntaxCheck;

/**
 * Trait WhereClauseTrait
 *
 * Provides methods for constructing SQL WHERE clauses dynamically.
 * It allows building WHERE clauses for SELECT, UPDATE, DELETE, and other SQL statements.
 */
trait WhereClauseTrait
{
    /**
     * Constructs an array of where clause objects.
     * The keys are "WHERE", "AND_1", "AND_2", "OR_3" ...
     *
     * @var array
     */
    public array $where_objs = [];

    /**
     * The constructed WHERE clause
     * @var string
     **/
    private string $where_clause = 'WHERE ';

    /**
     * Flag indicating if the WHERE clause has been completed
     * @var bool
     **/
    private bool $where_clause_completed = true;

    /**
     * Constructs a WHERE clause for equality.
     *
     * @param string $column The column name for equality comparison
     * @param string|int $value The value to compare for equality
     * @return $this
     */
    public function where_equals(string $column, string|int $value): static
    {
        $this
            ->validate_where_values($column, $value)
            ->add_where_clause_obj($column, '=', $value);
        $value = is_string($value) ? "'{$value}'" : $value;
        return $this->append_where_clause("{$column} = {$value}");
    }

    /**
     * Constructs a WHERE clause for not equal comparison.
     *
     * @param string $column The column name for not equal comparison
     * @param string|int $value The value to compare for not equal
     * @return $this
     */
    public function where_not_equals(string $column, string|int $value): static
    {
        $this
            ->validate_where_values($column, $value)
            ->add_where_clause_obj($column, '<>', $value);
        $value = is_string($value) ? "'{$value}'" : $value;
        return $this->append_where_clause("{$column} <> {$value}");
    }

    /**
     * Constructs a WHERE clause for greater than comparison.
     *
     * @param string $column The column name for greater than comparison
     * @param string|int $value The value to compare for greater than
     * @return $this
     */
    public function where_greater_than(string $column, string|int $value): static
    {
        $this
            ->validate_where_values($column, $value)
            ->add_where_clause_obj($column, '>', $value);
        $value = is_string($value) ? "'{$value}'" : $value;
        return $this->append_where_clause("{$column} > {$value}");
    }

    /**
     * Constructs a WHERE clause for greater than or equal comparison.
     *
     * @param string $column The column name for greater than or equal comparison
     * @param string|int $value The value to compare for greater than or equal
     * @return $this
     */
    public function where_greater_or_equal(string $column, string|int $value): static
    {
        $this
            ->validate_where_values($column, $value)
            ->add_where_clause_obj($column, '>=', $value);
        $value = is_string($value) ? "'{$value}'" : $value;
        return $this->append_where_clause("{$column} >= {$value}");
    }

    /**
     * Constructs a WHERE clause for less than comparison.
     *
     * @param string $column The column name for less than comparison
     * @param string|int $value The value to compare for less than
     * @return $this
     */
    public function where_less_than(string $column, string|int $value): static
    {
        $this
            ->validate_where_values($column, $value)
            ->add_where_clause_obj($column, '<', $value);
        $value = is_string($value) ? "'{$value}'" : $value;
        return $this->append_where_clause("{$column} < {$value}");
    }

    /**
     * Constructs a WHERE clause for less than or equal comparison.
     *
     * @param string $column The column name for less than or equal comparison
     * @param string|int $value The value to compare for less than or equal
     * @return $this
     */
    public function where_less_than_or_equal(string $column, string|int $value): static
    {
        $this
            ->validate_where_values($column, $value)
            ->add_where_clause_obj($column, '<=', $value);
        $value = is_string($value) ? "'{$value}'" : $value;
        return $this->append_where_clause("{$column} <= {$value}");
    }

    /**
     * Constructs a WHERE clause for BETWEEN comparison.
     *
     * @param string $column The column name for BETWEEN comparison
     * @param string|int $value1 The starting value for BETWEEN comparison
     * @param string|int $value2 The ending value for BETWEEN comparison
     * @return $this
     */
    public function where_between(string $column, string|int $value1, string|int $value2): static
    {
        return $this
            ->validate_where_values($column, $value1, $value2)
            ->add_where_clause_obj($column, '<>', $value1, $value2);
        $value1 = is_string($value1) ? "'$value1'" : $value1;
        $value2 = is_string($value2) ? "'$value2'" : $value2;
        $this->append_where_clause("{$column} BETWEEN {$value1} AND {$value2}");
    }

    /**
     * Constructs a WHERE clause for LIKE comparison.
     *
     * @param string $column The column name for LIKE comparison
     * @param string|int $value The value to compare for LIKE
     * @return $this
     */
    public function where_like(string $column, string|int $value): static
    {
        return $this
            ->validate_where_values($column, $value)
            ->add_where_clause_obj($column, 'LIKE', $value);
        $value = is_string($value) ? "'{$value}'" : $value;
        $this->append_where_clause("{$column} LIKE {$value}");
    }

    /**
     * Constructs a WHERE clause for IN comparison.
     *
     * @param string $column The column name for IN comparison
     * @param string|int ...$values The values for IN comparison
     * @return $this
     */
    public function where_in(string $column, string|int ...$values): static
    {
        $this->validate_where_values($column, ...$values)
            ->add_where_clause_obj($column, 'LIKE', $values);
        $value_string = '';
        foreach ($values as $key => $value) {
            $value_string .= is_string($value_string) ? "'{$value}'" : $value;
            if ($key !== array_key_last($values)) {
                $value_string .= ", ";
            }
        }
        return $this->append_where_clause("{$column} IN {$values}");
    }

    /**
     * Appends the logical OR operator to the WHERE clause.
     * Throws an error if the WHERE clause is empty or incomplete.
     *
     * @return $this
     * @throws SQLanguageError If the WHERE clause is empty or incomplete
     */
    public function or(): static
    {
        if ($this->where_clause === 'WHERE ') {
            throw new SQLanguageError("Can not append 'OR' operator to empty where clause.");
        }
        if (!$this->where_clause_completed) {
            throw new SQLanguageError("Can not append 'OR' operator to incomplete where clause.");
        }
        return $this->append_where_clause("OR", false);
    }

    /**
     * Appends the logical AND operator to the WHERE clause.
     * Throws an error if the WHERE clause is empty or incomplete.
     *
     * @return $this
     * @throws SQLanguageError If the WHERE clause is empty or incomplete
     */
    public function and(): static
    {
        if ($this->where_clause === 'WHERE ') {
            throw new SQLanguageError("Can not append 'AND' operator to empty where clause.");
        }
        if (!$this->where_clause_completed) {
            throw new SQLanguageError("Can not append 'AND' operator to incomplete where clause.");
        }
        return $this->append_where_clause("AND", false);
    }

    /**
     * Gets the constructed WHERE clause.
     *
     * @return string The constructed WHERE clause.
     * @throws SQLanguageError If the WHERE clause is incomplete.
     */
    public function get_where_clause(): string
    {
        if (!$this->where_clause_completed) {
            throw new SQLanguageError("WHERE Clause incomplete.");
        }
        if ($this->where_clause == "WHERE ") {
            return '';
        }
        return $this->where_clause;
    }

    /**
     * Constructs an array of where clause objects.
     * The keys are "WHERE", "AND_1", "AND_2", "OR_3" ...
     *
     * @return WhereClauseCondition[] WHERE Objects.
     * @throws SQLanguageError If the WHERE Objects emtpy.
     */
    public function get_where_objs(): array
    {
        if (!$this->where_objs) {
            throw new SQLanguageError("WHERE Objects empty. Be sure to initiate Database before using Statement class.");
        }
        return $this->where_objs;
    }

    /**
     * Validates the input values for constructing the WHERE clause.
     * Throws an error if the WHERE clause is already set or if the input values are improper for SQL.
     *
     * @param string $column The column name for the WHERE clause
     * @param string|int ...$values The values for the WHERE clause
     * @return $this
     * @throws SQLanguageError If the WHERE clause is already completed
     */
    private function validate_where_values(string $column, string|int ...$values): static
    {
        if ($this->where_clause !== 'WHERE ' && $this->where_clause_completed) {
            throw new SQLanguageError("Where clause already completed.");
        }
        SyntaxCheck::is_field_name($column);
        foreach ($values as $value) {
            SyntaxCheck::is_safe_value($value);
        }
        return $this;
    }

    /**
     * Appends the provided string to the WHERE clause.
     * Updates the $where_clause_completed flag accordingly.
     *
     * @param string $string The string to append to the WHERE clause
     * @param bool $clause_is_complete Flag indicating if the WHERE clause is complete after appending the string
     * @return $this
     */
    private function append_where_clause(string $string, bool $clause_is_complete = true): static
    {
        $this->where_clause .= trim($string) . " ";
        $this->where_clause_completed = $clause_is_complete;
        return $this;
    }

    /**
     * Helper for FileDatabase queries...
     * The keys are "WHERE", "AND_1", "AND_2", "OR_3" ...
     * @return  static
     */
    private function add_where_clause_obj(string $lhs, string $operator, mixed $rhs, mixed $rhs2 = null): static
    {
        if (Database::get_type() !== 'FileDatabase') {
            return $this;
        }
        if (empty($this->where_objs)) {
            $this->where_objs['WHERE'] = new WhereClauseCondition($lhs, $operator, $rhs, $rhs2);
            return $this;
        }
        if (str_ends_with($this->where_clause, 'AND')) {
            $this->where_objs['AND_' . count($this->where_objs)] = new WhereClauseCondition($lhs, $operator, $rhs, $rhs2);
            return $this;
        }
        if (str_ends_with($this->where_clause, 'OR')) {
            $this->where_objs['OR_' . count($this->where_objs)] = new WhereClauseCondition($lhs, $operator, $rhs, $rhs2);
            return $this;
        }
    }
}


/* FILE: ./Database/SQLanguage/Statement/Clause/ValuesClauseTrait.php */

<?php

namespace PHP_Library\Database\SQLanguage\Statement\Clause;

use PHP_Library\Database\SQLanguage\Error\SQLanguageError;
use PHP_Library\Database\SQLanguage\SyntaxCheck;

/**
 * Values WhereClauseTrait
 *
 * Provides methods for constructing SQL VALUE clauses dynamically.
 */
trait ValuesClauseTrait
{
    /**
     * The constructed VALUES clause
     * @var string
     **/
    public string $values_clause = '';

    /**
     * The list of single VALUES
     * @var array
     **/
    public array $values = [];

    /**
     * Flag indicating if the VALUES clause has been completed
     * @var bool
     **/
    private bool $values_clause_completed = false;

    public function values(string|int|float ...$value): self
    {
        if ($this->values_clause_completed) {
            throw new SQLanguageError("Can not append more values to complete VALUES clause.");
        }
        foreach ($value as $value) {
            SyntaxCheck::is_safe_value($value);
            $this->values[] = $value;
            if (is_string($value)) {
                $value = "'{$value}'";
            }
            $this->values_clause .= "{$value}, ";
        }
        $this->values_clause = "VALUES (" . rtrim($this->values_clause, ', ') . ")";
        $this->values_clause_completed = true;
        return $this;
    }

    /**
     * Gets the constructed VALUES clause.
     *
     * @return string The constructed VALUES clause.
     * @throws SQLanguageError If the VALUES clause is incomplete.
     */
    protected function get_values_clause(): string
    {
        if (!$this->values_clause_completed) {
            throw new SQLanguageError("VALUES Clause incomplete.");
        }
        return $this->values_clause;
    }
}


/* FILE: ./Database/SQLanguage/Statement/Clause/WhereClauseCondition.php */

<?php

namespace PHP_Library\Database\SQLanguage\Statement\Clause;

class WhereClauseCondition
{
    public string $operator;
    public string $lhs;
    public mixed $rhs;
    public mixed $rhs2;

    public function __construct(string $lhs, string $operator, mixed $rhs, mixed $rhs2 = null)
    {
        $this->operator = $operator;
        $this->lhs = $lhs;
        $this->rhs = $rhs;
        if ($operator === 'BETWEEN') {
            $this->rhs2 = $rhs2;
        }
    }
}


/* FILE: ./Database/SQLanguage/Statement/Select.php */

<?php

namespace PHP_Library\Database\SQLanguage\Statement;

use PHP_Library\Database\Database;
use PHP_Library\Database\SQLanguage\Error\SQLanguageError;

/**
 * Class Select
 *
 * Represents a SELECT statement builder.
 * Build Statement with `where()`.
 */
class Select extends AbstractStatement
{
    use Clause\WhereClauseTrait;

    /** @var string The LIMIT clause */
    private string $limit = '';

    /** @var null|array The result, which will be filled be execute and __deconstruct() */
    private ?array $result = null;

    /**
     * Constructs a Select statement. Convertible to a string.
     *
     * @param string $table The name of the table.
     * @param string $column The first column to select (default is '*')
     * @param string ...$more_columns Additional columns to select
     */
    public function __construct(string $table, string $column = '*', string ...$more_columns)
    {
        $this->set_table($table);
        if ($column === '*') {
            $this->columns_string = '*';
        } else {
            $this->set_columns(array_merge([$column], $more_columns));
        }
    }

    /**
     * Executes this Statement on current DB and returns the result of the query.
     * if the result is an array, and has just one element, it will return this element (recursivly).
     * @return mixed Success
     */
    public function get(bool $clean = true): mixed
    {
        $this->execute();
        return Database::get_query_result($clean);
    }

    /**
     * Sets the LIMIT clause for the SELECT statement.
     *
     * @param int $limit The maximum number of rows to return
     * @return Select Instance of the current Select for method chaining.
     */
    public function limit(int $limit): self
    {
        $this->limit = "LIMIT $limit";
        return $this;
    }

    public function __toString(): string
    {
        if (!$this->where_clause_completed) {
            throw new SQLanguageError("Statement is not completed.");
        }
        return "SELECT {$this->columns_string} FROM {$this->table} {$this->get_where_clause()} {$this->limit};";
    }
}


/* FILE: ./Database/SQLanguage/Statement/AbstractStatement.php */

<?php

namespace PHP_Library\Database\SQLanguage\Statement;

use PHP_Library\Database\Database;
use PHP_Library\Database\SQLanguage\SyntaxCheck;

/**
 * Class Select
 *
 * Implementations are a SELECT/INSERT/ ... classes representing sql statements.
 */
abstract class AbstractStatement
{
    /** @var string The name of the table */
    public readonly string $table;

    /** @var string The specified columns as string */
    public string $columns_string = '';

    /** @var array The specified columns */
    public array $columns = [];

    private bool $has_result = false;

    abstract public function __toString(): string;

    /**
     * Executes this Statement on current DB.
     * To access data, call `Database::get_query_result()`
     *
     * @return boolean Success
     */
    public function execute(): bool
    {
        return Database::query($this);
    }

    /**
     * Sets the table for the SELECT statement.
     *
     * @param string $table The name of the table. or an instance of AbstractTable
     * @return Select Instance of the current Select for method chaining.
     */
    protected function set_table(string $table): static
    {
        SyntaxCheck::is_table_name($table);
        $this->table = $table;
        return $this;
    }

    /**
     * Sets the columns to be selected in the statement.
     *
     * @param array $columns An array of column names
     * @return AbstractStatement Instance of the current statement for method chaining.
     */
    protected function set_columns(array $columns): static
    {
        foreach ($columns as $column) {
            SyntaxCheck::is_field_name($column);
            $this->columns[] = $column;
            $this->columns_string .= "{$column}, ";
        }
        $this->columns_string = rtrim($this->columns_string, ', ');
        return $this;
    }
}


/* FILE: ./Database/SQLanguage/Statement/Delete.php */

<?php

namespace PHP_Library\Database\SQLanguage\Statement;

use PHP_Library\Database\SQLanguage\Error\SQLanguageError;

/**
 * Class Delete
 *
 * Represents a DELETE statement.
 * Build Statement with `where()`.
 */
class Delete extends AbstractStatement
{
    use Clause\WhereClauseTrait;

    /**
     * Insert constructor.
     *
     * Constructs a Delete statement. Convertible to a string.
     *
     * @param string $table The name of the table.
     */
    public function __construct(string $table)
    {
        $this->set_table($table);
    }

    public function __toString(): string
    {
        if (!$this->where_clause_completed) {
            throw new SQLanguageError("Statement is not completed.");
        }
        return "DELETE FROM {$this->table} {$this->get_where_clause()};";
    }
}


/* FILE: ./Database/SQLanguage/Statement/Update.php */

<?php

namespace PHP_Library\Database\SQLanguage\Statement;

use PHP_Library\Database\SQLanguage\Error\SQLanguageError;
use PHP_Library\Database\SQLanguage\SyntaxCheck;

/**
 * Class Update
 *
 * Represents a UPDATE statement builder.
 * Build Statement with `where()` and `set()`.
 */
class Update extends AbstractStatement
{
    use Clause\WhereClauseTrait;

    private string $set = "SET ";

    public array $update_cells = [];

    /**
     * Insert constructor.
     *
     * Constructs a Update statement. Convertible to a string.
     *
     * @param string $table The name of the table or an instance of AbstractTable
     * @throws \InvalidArgumentException If the provided table or column names are invalid
     */
    public function __construct(string $table)
    {
        $this->set_table($table);
    }

    public function unset(string $column): self
    {
        return $this->set($column, null);
    }

    public function set(string $column, $value): self
    {
        SyntaxCheck::is_field_name($column);
        SyntaxCheck::is_safe_value($value);

        if ($this->set !== "SET ") {
            $this->set .= ', ';
        }
        $this->update_cells[$column] = $value;
        $value = is_string($value) ? "'$value'" : $value;
        $this->set .= "{$column} = {$value}";
        return $this;
    }

    public function __toString(): string
    {
        if (!$this->where_clause_completed) {
            throw new SQLanguageError("Statement is not completed.");
        }
        return "DELETE FROM {$this->table} {$this->get_where_clause()};";
    }
}


/* FILE: ./Database/SQLanguage/Statement/Insert.php */

<?php

namespace PHP_Library\Database\SQLanguage\Statement;

use PHP_Library\Database\SQLanguage\Error\SQLanguageError;

/**
 * Class Insert
 *
 * Represents a INSETRT statement.
 * Build Statement with `values()`.
 */
class Insert extends AbstractStatement
{
    use Clause\ValuesClauseTrait;
    /**
     *
     * Constructs a Insert statement.
     * @param string $table The name of the table.
     */
    public function __construct(string $table, string ...$columns)
    {
        $this->set_table($table);
        if ($columns) {
            $this->set_columns($columns);
        }
    }

    /**
     * @return string
     * @throws \Error If the VALUES clause is not completed.
     */
    public function __toString(): string
    {
        if (!$this->values_clause_completed) {
            throw new SQLanguageError("Statement is not completed.");
        }
        $columns = $this->columns_string ? "({$this->columns_string})" : '';
        return "INSERT INTO {$this->table} {$columns} {$this->get_values_clause()};";
    }
}


/* FILE: ./Database/SQLanguage/SyntaxCheck.php */

<?php

namespace PHP_Library\Database\SQLanguage;

use PHP_Library\Database\SQLanguage\Error\SQLanguageError;

class SyntaxCheck
{
    public static bool $throws_errors = true;

    private function __construct() {}

    public static function is_safe_value(string|null $value)
    {
        $value = is_null($value) ? 'NULL' : $value;
        if (preg_match('/[\'";]/', $value)) {
            return self::throw_exception("`$value` is not a safe value.");
        }
        return true;
    }


    /**
     * Checks if a given string is a valid SQL field name.
     * For table column names, keys in general...
     *
     * @param string $field_name The name to check.
     *
     * @return bool True if the field name is valid; otherwise, false.
     */
    public static function is_field_name(string $field_name): bool
    {
        if (20 < strlen($field_name)) {
            return self::throw_exception("`$field_name` is an invalid name: too long for a field name.");
        }
        $first_character = $field_name[0];
        if (!ctype_alpha($first_character)) {
            return self::throw_exception("`$field_name` is an invalid name: first character must be [a-Z].");
        }
        foreach (str_split($field_name) as $character) {
            if ((!ctype_alpha($character)) && $character != '_') {
                return self::throw_exception("`$field_name` is an invalid name: character must be [a-Z] or '_'.");
            }
        }
        return true;
    }

    /**
     * Checks if a given string is a valid SQL table name.
     * For table names
     *
     * @param string $table_name The name to check.
     *
     * @return bool True if the table name is valid; otherwise, false.
     */
    public static function is_table_name(string $table_name): bool
    {
        if (20 < strlen($table_name)) {
            return self::throw_exception("`$table_name` is an invalid name: too long for a table name.");
        }
        $first_character = $table_name[0];
        if (!ctype_lower($first_character)) {
            return self::throw_exception("`$table_name` is an invalid name: first character must be [a-z].");
        }
        foreach (str_split($table_name) as $character) {
            if ((!ctype_lower($character)) && $character != '_') {
                return self::throw_exception("`$table_name` is an invalid name: character must be [a-z] or '_'.");
            }
        }
        return true;
    }

    /**
     * Checks if a given string is a valid SQL data type.
     *
     * @param string $type The SQL data type to check.
     *
     * @return bool True if the data type is valid; otherwise, false.
     */
    public static function is_data_type(string $type): bool
    {

        if (!preg_match(
            pattern: '/^(bigint\((\d+)\)|varchar\((\d+)\)|int\((\d+)\)|text|tinytext|datetime)\s*(unsigned)?$/',
            subject: $type
        )) {
            return self::throw_exception("`$type` is an invalid type.");
        }
        return true;
    }

    /**
     * Checks if a given SQL data type is indexable.
     *
     * @param string $type The SQL data type to check.
     *
     * @return bool True if the data type is indexable; otherwise, false.
     */
    public static function is_indexable_data_type(string $type): bool
    {
        $matches = [];
        if (!preg_match(
            pattern: '/^(bigint\((\d+)\)|varchar\((\d+)\)|int\((\d+)\)|datetime)\s*(unsigned)?$/',
            subject: $type,
            matches: $matches
        )) {
            return self::throw_exception("`$type` is not an indexable type.");
        }
        foreach ($matches as $match) {
            if (!$match) continue;
            if ($match === $type) continue;
            if ($match > 20) {
                return self::throw_exception("`$type` is not an indexable type. $match is larger than 20.");
            }
        }
        return true;
    }

    private static function throw_exception(string $message): bool
    {
        if (static::$throws_errors) {
            throw new SQLanguageError($message);
        }
        return false;
    }
}


/* FILE: ./Database/SQLDatabase.php */

<?php

namespace  PHP_Library\Database;

use  PHP_Library\Settings\Settings;
use PDO;
use PDOStatement;
use PHP_Library\Database\SQLanguage\Statement\AbstractStatement;
use PHP_Library\Database\Table\Column\Column;
use PHP_Library\Database\Table\SQLTable;
use PHP_Library\Database\Error\DatabaseError;

/**
 * DatabaseStorage is a class that handles database storage using PDO.
 */
class SQLDatabase extends Database
{
    private static PDO $pdo;
    private static PDOStatement $result;

    /**
     * Initialize the database connection.
     *
     * @return bool Returns true if initialization is successful, false otherwise.
     */
    protected static function initalize(): bool
    {
        Settings::register('Database/database_name');
        Settings::register('Database/database_username');
        Settings::register('Database/database_password');
        try {
            $databasename = Settings::get('Database/database_name', true);
            $username = Settings::get('Database/database_username', true);
            $password = Settings::get('Database/database_password', true);
        } catch (\Throwable $t) {
            throw new DatabaseError($t);
        }

        $host = ($host = Settings::get('Database/database_host')) ? $host : 'localhost';
        $port = ($port = Settings::get('Database/database_port')) ? $port : '3306';
        $charset = ($charset = Settings::get('Database/database_charset')) ? $charset : 'utf8mb4';
        $driver = ($driver = Settings::get('Database/database_driver')) ? $driver : 'mysql';

        $dns = "$driver:host=$host";
        $dns .= $databasename ? ";dbname=$databasename" : '';
        $dns .= ";port=$port";
        $dns .= ";charset=$charset";
        $options = [
            PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            PDO::ATTR_EMULATE_PREPARES   => false,
        ];
        try {
            $pdo = new PDO(
                $dns,
                $username,
                $password,
                $options
            );
        } catch (\Throwable $t) {
            DatabaseError::trigger("Could not initalize SQL-Database connection: " . $t->getMessage());
        }
        self::$pdo = $pdo;
        return true;
    }

    public static function last_insert_id(): int|false
    {
        return self::$pdo->lastInsertId();
    }

    /**
     * Get a table instance by name.
     *
     * @param string $table_name The name of the table.
     * @return SQLTable The table instance.
     */
    public static function get_table(string $table_name): SQLTable
    {
        return new SQLTable($table_name);
    }

    /**
     * Create a table with the given name and columns.
     *
     * @param string $table The name of the table.
     * @param TableColumn ...$columns The columns to create.
     */
    public static function create_table(string $table, Column ...$columns): bool
    {
        $sql_query = "CREATE TABLE $table (";
        foreach ($columns as $column) {
            $additional = '';
            switch ($column->type) {
                case 'int':
                    $var_type = "INT(255)";
                    break;
                case 'string':
                    $var_type = "VARCHAR(255)";
                    break;
                case 'bool':
                    $var_type = "BOOL";
                    break;
                case 'float':
                    $var_type = "FLOAT(24)";
                    break;

                default:
                    DatabaseError::trigger("$column->type as VAR_TYPE is not supported.");
            }
            if ($column->timestamp) {
                $var_type = 'TIMESTAMP';
                $additional .= "DEFAULT CURRENT_TIMESTAMP ";
            }
            if (!$column->nullable) {
                $additional .= "NOT NULL";
            }
            $sql_query .= "$column->name $var_type $additional, ";
        }
        $sql_query = trim($sql_query, ", ") . ")";
        self::unsafe_query($sql_query);

        return true;
    }

    /**
     * Check if table exists
     *
     * @param string $name The name of the table.
     * @return bool
     */
    public static function table_exists(string $name): bool
    {
        $sql_query = "SHOW TABLES LIKE '$name'";
        self::unsafe_query($sql_query);
        return (bool) self::get_queried_data();
    }

    protected static function get_queried_data(bool $clean_array = false): mixed
    {
        $mode = PDO::FETCH_ASSOC;
        $query_result = self::$result->fetchAll($mode);
        if ($clean_array) {
            return static::clean_array($query_result);
        }
        return $query_result;
    }

    protected static function execute_query(AbstractStatement $sql_statement): bool
    {
        try {
            self::$result = self::$pdo->query($sql_statement);
        } catch (\Throwable $t) {
            return false;
        }
        return true;
    }

    private static function unsafe_query(string $sql_statement): bool
    {
        try {
            self::$result = self::$pdo->query($sql_statement);
        } catch (\Throwable $t) {
            return false;
        }
        return true;
    }
}


/* FILE: ./Database/FileDatabaseAggregate/FileDatabaseAggregate.php */

<?php

namespace PHP_Library\Database\FileDatabaseAggregate;

use PHP_Library\Database\Database;
use PHP_Library\Database\Error\DatabaseError;
use PHP_Library\Database\FileDatabase;
use PHP_Library\Database\SQLanguage\Statement\Delete;
use PHP_Library\Database\SQLanguage\Statement\Insert;
use PHP_Library\Database\SQLanguage\Statement\Select;
use PHP_Library\Database\SQLanguage\Statement\Update;
use PHP_Library\Database\Table\FileTable;

trait FileDatabaseAggregate
{
    protected static function execute_delete(Delete $sql_statement): int
    {
        $row_ids = self::get_row_ids_from_where_clause($sql_statement);
        $deleted_rows = 0;
        foreach (FileDatabase::$data[$sql_statement->table] as $column_name => $column) {
            foreach ($row_ids as $i => $row_id) {
                unset(FileDatabase::$data[$sql_statement->table][$column_name][$row_id]);
                if ($column_name === array_key_last(FileDatabase::$data[$sql_statement->table])) {
                    $deleted_rows++;
                }
            }
        }
        return $deleted_rows;
    }

    protected static function execute_insert(Insert $sql_statement): int
    {
        $table_name = $sql_statement->table;
        $columns_info = static::get_columns_info($table_name);
        $values = $sql_statement->values;

        $row_cells = [];
        if (! $sql_statement->columns_string || $sql_statement->columns_string == "*") {
            foreach ($columns_info as $column_name => $column_property) {
                if ($column_property['auto_increment']) {
                    $row_cells[$column_name] = null;
                } else {
                    $row_cells[$column_name] = array_shift($values);
                }
            }
        } else {
            foreach ($sql_statement->columns as $column_name) {
                if ($columns_info[$column_name]['auto_increment']) {
                    $row_cells[$column_name] = null;
                } else {
                    $row_cells[$column_name] = array_shift($values);
                }
            }
        }
        return static::insert_row($table_name, $row_cells);
    }

    protected static function execute_select(Select $sql_statement): array
    {
        $table_name = $sql_statement->table;
        $row_ids = self::get_row_ids_from_where_clause($sql_statement);
        $rows = [];
        if ($sql_statement->columns_string === "*") {
            foreach ($row_ids as $row_id) {
                $rows[] = static::get_row($table_name, $row_id);
            }
        } else if ($select_columns = explode(',', $sql_statement->columns_string)) {
            $first_column = array_shift($select_columns);
            foreach ($row_ids as $row_id) {
                $rows[] = static::get_row($table_name, $row_id, $first_column, ...$select_columns);
            }
        } else {
            foreach ($row_ids as $row_id) {
                $rows[] = static::get_row($table_name, $row_id, $sql_statement->columns_string);
            }
        }
        return $rows;
    }

    protected static function execute_update(Update $sql_statement): int
    {
        $table_name = $sql_statement->table;
        $row_ids = static::get_row_ids_from_where_clause($sql_statement);
        $updated_rows = 0;
        foreach ($row_ids as $row_id) {
            foreach ($sql_statement->update_cells as $column_name => $value) {
                static::set_cell($table_name, $column_name, $row_id, $value);
            }
            $updated_rows++;
        }
        return $updated_rows;
    }

    /**
     * Get the row-IDs where the 'WHERE-Clause' matches
     *
     * @param Select $sql_statement Statement with WHERE clause
     * @return array the IDs
     */
    private static function get_row_ids_from_where_clause(Select|Delete|Update $sql_statement): array
    {
        $table_name = $sql_statement->table;
        if (! $sql_statement->get_where_clause()) {
            // assuming the first column is complete
            $first_column = array_key_first(FileDatabase::$data[$table_name]);
            return array_keys(FileDatabase::$data[$table_name][$first_column]);
        }
        $row_ids = [];
        foreach ($sql_statement->get_where_objs() as $and_or_or => $where_clause) {
            $l_operant = $where_clause->lhs;
            $r_operant = $where_clause->rhs;
            $r_operant2 = isset($where_clause->rhs2) ? $where_clause->rhs2 : null;
            switch ($where_clause->operator) {
                case '=':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_equals($table_name, $l_operant, $r_operant));
                    break;
                case '>':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_greater_than($table_name, $l_operant, $r_operant));
                    break;
                case '>=':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_greater_or_equal($table_name, $l_operant, $r_operant));
                    break;
                case '<':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_smaller($table_name, $l_operant, $r_operant));
                    break;
                case '<=':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_smaller_or_equal($table_name, $l_operant, $r_operant));
                    break;
                case '<>':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_not_equals($table_name, $l_operant, $r_operant));
                    break;
                case 'BETWEEN':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_between($table_name, $l_operant, $r_operant, $r_operant2));
                    break;
                case 'LIKE':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_like($table_name, $l_operant, $r_operant));
                    break;
                case 'IN':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_in($table_name, $l_operant, $r_operant));
                    break;
                case 'NOT IN':
                    $row_ids = static::operate_row_array($and_or_or, $row_ids, static::get_ids_where_not_in($table_name, $l_operant, $r_operant));
                    break;
                default:
                    DatabaseError::trigger("Method for '{$where_clause->operator}'-operator not implemented.");
            }
        }
        return $row_ids;
    }

    private static function operate_row_array(string $operator, ...$arrays)
    {
        if (str_starts_with($operator, 'AND')) {
            return array_intersect(...$arrays);
        }
        return array_merge(...$arrays);
    }

    private static function get_row(string $table, int $row_id, string $select_column = "*", string ...$select_columns): array
    {
        if ($select_column === "*") {
            $select_columns = array_keys(FileDatabase::$data[$table]);
            // hide the row_id column.
            $row_id_column = array_search(FileTable::$default_id_column_name, $select_columns);
            unset($select_columns[$row_id_column]);
        } else {
            $select_columns = array_merge([$select_column], $select_columns);
            $select_columns = array_map(function ($value) {
                return trim($value);
            }, $select_columns);
        }
        $row = [];
        foreach (FileDatabase::$data[$table] as $column => $entries) {
            if (in_array($column, $select_columns)) {
                $row[$column] = $entries[$row_id];
            }
        }
        return $row;
    }

    private static function get_ids_where_equals(string $table, string $column, mixed $value): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if ($cell === $value) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_where_not_equals(string $table, string $column, mixed $value): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if ($cell !== $value) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_where_greater_than(string $table, string $column, mixed $value): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if ($cell > $value) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_where_greater_or_equal(string $table, string $column, mixed $value): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if ($cell >= $value) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_less_than(string $table, string $column, mixed $value): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if ($cell < $value) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_where_less_than_or_equal(string $table, string $column, mixed $value): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if ($cell <= $value) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_where_between(string $table, string $column, int|float $lower, int|float $higher): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if ($lower < $cell && $cell < $higher) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_where_like(string $table, string $column, mixed $value): array
    {
        $ids = [];
        // '%'-Wildcard
        $value = preg_replace('/(?<!\\)%/', '.*', $value);
        // '_'-Wildcard
        $value = preg_replace('/(?<!\\)_/', '.', $value);
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if (preg_match($value, $cell)) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_where_in(string $table, string $column, array $values): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if (array_search($cell, $values)) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_ids_where_not_in(string $table, string $column, array $values): array
    {
        $ids = [];
        foreach (FileDatabase::$data[$table][$column] as $id => $cell) {
            if (! array_search($cell, $values)) {
                $ids[] = $id;
            }
        }
        return $ids;
    }

    private static function get_columns_info(string $table_name): array
    {
        $columns_info = FileDatabase::$data['%tables'][$table_name];
        unset($columns_info['%primary_key']);
        return $columns_info;
    }

    private static function get_primary_key(string $table_name): string
    {
        return FileDatabase::$data['%tables'][$table_name]['%primary_key'];
    }

    private static function set_cell(string $table_name, string $column_name, int $row_id, mixed $value = null): bool
    {
        $columns_info = static::get_columns_info($table_name);
        if (! key_exists($column_name, $columns_info)) {
            return false;
        }
        $primary_key = static::get_primary_key($table_name);
        if ($column_name == $primary_key) {
            if (false !== array_search($value, FileDatabase::$data[$table_name][$column_name], true)) {
                DatabaseError::trigger("$table_name.$column_name (primary key) must be unique.");
                return false;
            }
        }
        if ($columns_info[$column_name]['auto_increment']) {
            $last_ai_value_key = array_key_last(FileDatabase::$data[$table_name][$column_name]);
            $last_ai_value = is_null($last_ai_value_key) ? 0 : FileDatabase::$data[$table_name][$column_name][$last_ai_value_key];
            FileDatabase::$data[$table_name][$column_name][$row_id] = $last_ai_value + 1;
            return true;
        }
        if ($columns_info[$column_name]['timestamp']) {
            FileDatabase::$data[$table_name][$column_name][$row_id] = date('Y-m-d H:i:s', time());
            return true;
        }
        if (! static::is_value_in_column_allowed($table_name, $column_name, $value)) {
            DatabaseError::trigger("Value for '$column_name' needs to be type of '{$columns_info[$column_name]['type']}' in '$table_name'.");
            return false;
        }
        FileDatabase::$data[$table_name][$column_name][$row_id] = $value;
        return true;
    }

    private static function set_row(string $table_name, ?int $row_id = null, array $row_cells = []): int
    {
        $columns_info = static::get_columns_info($table_name);
        $set_cells = 0;
        foreach ($columns_info as $column_name => $column_property) {
            // if it's an auto increment column but a value is given.
            if ($column_property['auto_increment'] && isset($row_cells[$column_name]) && $row_cells[$column_name]) {
                DatabaseError::trigger("$table_name.$column_name is an auto increment column. can not accept value other than null.");
            }
            // if the value is not set / empty.
            if ((!isset($row_cells[$column_name]) || ! $row_cells[$column_name]) && !$column_property['nullable']) {
                // exception: auto increment will always be unset. set it here to null,
                if (! $column_property['auto_increment']) {
                    DatabaseError::trigger("$table_name.$column_name can not be empty/null");
                } else {
                    $row_cells[$column_name] = null;
                }
            } else {
                $value = $row_cells[$column_name];
            }
            unset($row_cells[$column_name]);
            $set_cells = $set_cells + (int) static::set_cell($table_name, $column_name, $row_id, $value);
        }
        if (!empty($row_cells)) {
            DatabaseError::trigger("Missing keys: " . implode(', ', array_keys($row_cells)));
        }
        return $set_cells;
    }

    // returns new row_id
    private static function insert_row(string $table_name, array $row_cells): int
    {
        $columns_info = static::get_columns_info($table_name);
        $new_row_key = static::get_new_insert_row_key($table_name);
        foreach ($columns_info as $column_name => $column_property) {
            if ($column_property['auto_increment']) {
                static::set_cell($table_name, $column_name, $new_row_key, null);
                continue;
            }
            if (!isset($row_cells[$column_name]) && !$column_property['nullable']) {
                DatabaseError::trigger("$table_name.$column_name can not be empty/null");
                continue;
            }
            $value = $row_cells[$column_name];
            unset($row_cells[$column_name]);
            static::set_cell($table_name, $column_name, $new_row_key, $value);
        }
        return isset($new_row_key) ? $new_row_key + 1 : 1;
    }

    // 'key' in array start with 0, 'id' in a table row with 1
    private static function get_new_insert_row_key(string $table_name): int
    {
        $first_column = array_key_first(FileDatabase::$data[$table_name]);
        $highest_current_key = array_key_last(FileDatabase::$data[$table_name][$first_column]);
        if (is_int($highest_current_key)) {
            return $highest_current_key + 1;
        }
        return 0;
    }

    private static function count_nullable_columns(string $table_name): int
    {
        $count_columns = 0;
        $columns_info = static::get_columns_info($table_name);
        foreach ($columns_info as $column_property) {
            if ($column_property['nullable']) {
                $count_columns--;
            }
        }
        return $count_columns + count($columns_info);
    }

    /**
     * Check if a value is allowed in a column.
     *
     * @param string $table The table name.
     * @param string $column_name The column name.
     * @param mixed $value The value to check.
     * @return bool Returns true if the value is allowed, false otherwise.
     */
    private static function is_value_in_column_allowed(string $table, string $column_name, mixed $value): bool
    {
        $columns_infos = static::get_columns_info($table);
        if ($columns_infos[$column_name]['timestamp']) {
            return true;
        }
        if ($columns_infos[$column_name]['nullable'] && empty($value)) {
            return true;
        }
        if ($columns_infos[$column_name]['type'] == gettype($value) && !is_null($value)) {
            return true;
        }
        return false;
    }
}


/* FILE: ./SMTPClient/SMTPClient.php */

<?php

namespace PHP_Library\SMTPClient;

use PHPMailer\PHPMailer\PHPMailer;
use PHPMailer\PHPMailer\SMTP;

class SMTP_Client
{
    protected PHPMailer $mailer;

    public function __construct(
        string $sender_name,
        string $username,
        string $password,
        string $host,
        int $port
    ) {
        $this->mailer = new PHPMailer();
        $this->mailer->Username = $username;
        $this->mailer->Password = $password;
        $this->mailer->Host = $host;
        $this->mailer->Port = $port;
        $this->mailer->setFrom($username, $sender_name);
        $this->mailer->isHTML(true);
        $this->mailer->isSMTP();
        $this->mailer->CharSet = "UTF-8";
        $this->mailer->Encoding = 'base64';
        $this->mailer->SMTPAuth   = true;
        $this->mailer->SMTPSecure = PHPMailer::ENCRYPTION_SMTPS;
    }

    public static function create_from_ini(string $ini_file): static
    {
        $smtp_config = parse_ini_file($ini_file, true);

        $required_fields = [
            'Sender',
            'Username',
            'Port',
            'Host',
            'Password'
        ];

        foreach ($required_fields as $name => $value) {
            if (!key_exists($name, $smtp_config)) {
                throw new \Error("Key '{$name}' is missing");
            }
        }

        $smtp_client = new self(
            sender_name: $smtp_config['Sender'],
            username: $smtp_config['Username'],
            password: $smtp_config['Password'],
            host: $smtp_config['Host'],
            port: $smtp_config['Port']
        );

        foreach ($smtp_config as $name => $value) {
            $smtp_client->$name = $value;
        }
        return $smtp_client;
    }

    public function mail_to(string $recipent, string $subject, string $html_body): static
    {
        try {
            $this->mailer->addAddress($recipent);
            $this->mailer->Subject = $subject;
            $this->mailer->Body = $html_body;
            $this->mailer->send();
        } catch (\Exception $e) {
            if ($this->mailer->SMTPDebug) {
                echo $e->getMessage();
            }
        }
        return $this;
    }

    public function __set($name, $value): void
    {
        if ('debug' === strtolower($name)) {
            if (!$value) {
                $this->mailer->SMTPDebug = SMTP::DEBUG_OFF;
            } else if (is_int($value)) {
                $this->mailer->SMTPDebug = $value;
            } else {
                $this->mailer->SMTPDebug = SMTP::DEBUG_SERVER;
            }
        } else {
            $this->mailer->$name = $value;
        }
    }

    public function __get($name): mixed
    {
        return $this->mailer->$name;
    }
}


/* FILE: ./UserModel/UserManagement.php */

<?php

namespace  PHP_Library\UserManagement;

use Debug\Debug;
use Model\Model;

class User extends Model
{
    public string $password;
    public string $email;
    public ?string $name;
    public function __construct(string $email, string $name)
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new \Error("'$email' is not an email.");
        }
        $this->email = $email;
        $this->name = $name;
    }

    public function register(string $password): User
    {
        if (self::has_instance_with_value('email', $this->email)) {
            throw new \Error("User '$this->email' already registered.");
        }
        if (!self::validate_password($password)) {
            throw new \Error("Password is not safe.");
        }
        self::add_instance([
            'name' => $this->name,
            'email' => $this->email,
            'password' => password_hash($password, PASSWORD_DEFAULT)
        ]);
        return $this;
    }

    public function authenticate(string $password): User
    {
        if (!password_verify(
            password: $password,
            hash: self::get_value_where('password', "username = '{$this->email}'")
        )) {
            throw new \Error("Could not login '{$this->email}'.");
        }
        return $this;
    }

    public static function get(int $id): User
    {
        return self::get_instance($id);
    }

    private static function validate_password(string $password)
    {
        if (
            strlen($password) >= 8 &&
            preg_match('@[0-9]@', $password) &&
            preg_match('@[A-Z]@', $password) &&
            preg_match('@[a-z]@', $password) &&
            preg_match('@[^\w]@', $password)
        ) {
            return true;
        }
        return false;
    }
}

/* FILE: ./Superglobals/Session.php */

<?php

namespace PHP_Library\Superglobals;

use PHP_Library\Error\Warning;
use PHP_Library\Superglobals\Error\SessionError;

/**
 * Session is started by most of the methods. It must be started prior the first output. Use `Session::start()`, if the first other method is called within output.
 */
class Session
{
    public static string $name;
    public static ?string $id = null;

    public static function start(?string $name = null): bool
    {
        if ($name) {
            session_name($name);
        }
        if (!session_start()) {
            return false;
        }
        static::$name = session_name();
        static::$id = session_id();
        return true;
    }

    public static function has_field(string $key): bool
    {
        static::populate_session_array();
        return isset($_SESSION[$key]);
    }

    public static function get(string $key): mixed
    {
        if (!static::has_field($key)) {
            Warning::trigger("Undefined Session Field '{$key}'");
            return null;
        }
        return $_SESSION[$key];
    }

    public static function set(string $key, mixed $value): void
    {
        static::populate_session_array();
        $_SESSION[$key] = $value;
    }

    /**
     * without args, the whole session will be cleared on the server!!
     * @param null|string $key
     * @param null|string ...$keys
     * @return bool
     * @throws SessionError
     */
    public static function unset(?string $key = null, ?string ...$keys): bool
    {
        static::populate_session_array();
        if (is_null($key) && !empty($keys)) {
            throw new SessionError("When unsetting the whole session, just `Session::unset(null)`.");
        }
        if (is_null($key)) {
            return session_unset();
        }
        $keys = array_merge([$key], $keys);
        foreach ($keys as $keys) {
            unset($_SESSION[$keys]);
        }
        return true;
    }

    public static function destroy(): bool
    {
        if (is_null(static::$name)) {
            throw new SessionError("Session not started.");
        }
        if (!session_destroy()) {
            return false;
        }
        $params = session_get_cookie_params();
        return setcookie(
            static::$name,
            '',
            time() - 42000,
            $params["path"],
            $params["domain"],
            $params["secure"],
            $params["httponly"]
        );
    }

    protected static function populate_session_array(): bool
    {
        if (is_null(static::$id)) {
            return static::start();
        }
        return true;
    }
}


/* FILE: ./Superglobals/Error/SessionError.php */

<?php

namespace PHP_Library\Superglobals\Error;

class SessionError extends \PHP_Library\Error\Error {}


/* FILE: ./Superglobals/Error/CookieError.php */

<?php

namespace PHP_Library\Superglobals\Error;

class CookieError extends \PHP_Library\Error\Error {}


/* FILE: ./Superglobals/Cookie.php */

<?php

namespace PHP_Library\Superglobals;

use PHP_Library\Error\Warning;
use PHP_Library\Superglobals\Error\CookieError;

class Cookie
{
    protected static array $cookie_parameters = [];

    public static function has_field(string $key): bool
    {
        return isset($_COOKIE[$key]);
    }

    /**
     * returns false if cookie is not set.
     *
     * @param [type] $key
     * @return mixed
     */
    public static function get(string $key): mixed
    {
        if (!static::has_field($key)) {
            Warning::trigger("Undefined Cookie Field '{$key}'");
            return null;
        }
        $value = $_COOKIE[$key];
        if (
            isset(static::$cookie_parameters[$key])
            && isset(static::$cookie_parameters[$key]['type'])
        ) {
            $type = static::$cookie_parameters[$key]['type'];
            if ($type === 'array') {
                return static::decode_str_to_array($value);
            }
            return settype($value, $type);
        }
        if (ctype_digit($value)) {
            return (int) $value;
        }
        if ($array = static::decode_str_to_array($value)) {
            return $array;
        }
        return (string) $value;
    }
    /**
     * Send a cookie. Will not work if output is already send. Values will be avaible when working on the next request using `Cookie::get($name)`.
     * @link https://php.net/manual/en/function.setcookie.php
     * @param string $name The name of the cookie.
     * @param string|array|int $value The value of the cookie. It is stored on the client; do not store sensitive information.
     * @param int|null $expire_in_seconds The number of seconds before the cookie is expired. If set to 0, the cookie will expire at the end of the session (when the browser closes). If set to 'null' and the browser will delete it.
     * @param string $path The path on the server in which the cookie will be available on.
     * @param string $domain The domain that the cookie is available.
     * @param bool $secure Indicates that the cookie should only be transmitted over a secure HTTPS connection from the client.
     * @param bool $httponly When true the cookie will be made accessible only through the HTTP protocol.
     * @return bool Success.
     */
    public static function set(string $name, string|array|int|float $value, ?int $expire_in_seconds = 0, string $path = "", string $domain = "", bool $secure = false, bool $httponly = false): bool
    {
        if (is_null($expire_in_seconds)) {
            $expires_or_options = 1;
        } else if ($expire_in_seconds === 0) {
            $expires_or_options = $expire_in_seconds;
        } else {
            $expires_or_options = time() + $expire_in_seconds;
        }
        static::$cookie_parameters[$name] = [
            'type' => gettype($value),
            'path' => $path,
            'domain' => $domain,
            'secure' => $secure,
            'httponly' => $httponly
        ];
        if (is_array($value)) {
            $value = http_build_query($value, encoding_type: PHP_QUERY_RFC3986);
        }
        return setcookie($name, $value, $expires_or_options, $path, $domain, $secure, $httponly);
    }

    public static function unset(string ...$names): bool
    {
        foreach ($names as $name) {
            if (isset($_COOKIE[$name])) {
                unset($_COOKIE[$name]);
            }
            if (isset(static::$cookie_parameters[$name])) {
                $path = static::$cookie_parameters[$name]['path'];
                $domain = static::$cookie_parameters[$name]['domain'];
                $secure = static::$cookie_parameters[$name]['secure'];
                $httponly = static::$cookie_parameters[$name]['httponly'];
                if (!static::set($name, '', null, $path, $domain, $secure, $httponly)) {
                    return false;
                }
            } else {
                if (!static::set($name, '', null)) {
                    return false;
                }
            }
        }
        return true;
    }

    protected static function decode_str_to_array(string $string): array|false
    {
        $values = [];
        if (!$key_value_strings = explode('&', $string)) {
            return false;
        }
        foreach (explode('&', $string) as $key_value_str) {
            $kv = explode('=', $key_value_str);
            if (count($key_value_strings) === 1 && count($kv) === 1) {
                return false;
            }
            $key = urldecode($kv[0]);
            $value = isset($kv[1]) ? urldecode($kv[1]) : true;
            $values[$key] = $value;
        }
        return $values;
    }
}


/* FILE: ./Superglobals/Server.php */

<?php

namespace PHP_Library\Superglobals;

use PHP_Library\Superglobals\PHPTraits\QueryTrait;
use PHP_Library\Superglobals\PHPTraits\ServerTrait;

/**
 * Class Server
 *
 * A class that provides easy access to $_SERVER superglobal array elements
 * as static methods. The class also overrides __toString() to return the
 * value of PHP_SELF for better readability.
 */
class Server
{
    use ServerTrait;
    use QueryTrait;

    /**
     * Checks if the current request method is POST.
     *
     * @return bool True if the request method is POST, false otherwise.
     */
    public static function has_post_request(): bool
    {
        return self::get_request_method() == 'POST';
    }

    /**
     * Converts a file path to a URL. Throws an error if the file path is out of scope.
     *
     * @param string $path The file path to convert to a URL.
     * @return string The URL to the file.
     * @throws \Error If the path is outside the document root.
     */
    public static function get_url_to_file(string $path): string
    {
        // Absolute path
        if (str_starts_with($path, '/')) {
            if (!str_starts_with($path, self::get_document_root())) {
                throw new \Error("'$path' is out of scope for this script.");
            }
            $path = substr($path, strlen(self::get_document_root()));
        }
        // Relative path
        return self::get_root_url() . '/' . $path;
    }

    /**
     * Checks if the current HTTP request method matches a given type.
     *
     * @param string $http_request_type The HTTP request type (GET, POST, etc.) to check for.
     * @return bool True if the request method matches, false otherwise.
     */
    public static function has_http_request_type(string $http_request_type): bool
    {
        return self::get_request_method() === strtoupper($http_request_type);
    }

    /**
     * Returns the current URL being accessed, including the protocol and port.
     *
     * @return string The current URL.
     * @throws \Error If the script is not serving a request (i.e., it's running in CLI mode).
     */
    public static function get_root_url(): string
    {
        if (! self::is_serving_http()) {
            return throw new \Error('This Script is not Serving. There is no URL');
        }
        $port = self::get_port();
        if (
            isset($_SERVER['HTTPS']) &&
            ($_SERVER['HTTPS'] == 'on' || $_SERVER['HTTPS'] == 1) ||
            isset($_SERVER['HTTP_X_FORWARDED_PROTO']) &&
            $_SERVER['HTTP_X_FORWARDED_PROTO'] == 'https'
        ) {
            $protocol = 'https://';
        } else {
            $protocol = 'http://';
        }

        if (!$port) {
            return $protocol .  self::get_server_name();
        }
        return $protocol .  self::get_server_name() . ":$port";
    }

    /**
     * Checks if the request is being made from a local environment (localhost or local IP).
     *
     * @return bool True if the request is from a local environment, false otherwise.
     */
    public static function is_local(): bool
    {
        return (
            $_SERVER['HTTP_HOST'] == 'localhost'
            || substr($_SERVER['HTTP_HOST'], 0, 3) == '10.'
            || substr($_SERVER['HTTP_HOST'], 0, 7) == '192.168'
        );
    }

    /**
     * Checks if the script is running in CLI (Command Line Interface) mode.
     *
     * @return bool True if the script is running in CLI mode, false otherwise.
     */
    public static function is_cli(): bool
    {
        return is_int(strpos(php_sapi_name(), 'cli'));
    }

    /**
     * Checks if the script is serving an HTTP request (i.e., not in CLI mode).
     *
     * @return bool True if the script is serving a request, false otherwise.
     */
    public static function is_serving_http(): bool
    {
        return ! self::is_cli();
    }

    /**
     * Alias of get_server_addr().
     * Returns the IP address of the server, or an empty string if not available.
     *
     * @return string The server's IP address, or an empty string if not serving.
     */
    public static function get_ip_address(): string
    {
        return self::get_server_addr() ?? '';
    }

    /**
     * Alias of get_server_name().
     * Returns the name of the server host, or an empty string if not available.
     *
     * @return string The server name, or an empty string if not serving.
     */
    public static function get_name(): string
    {
        return self::get_server_name() ?? '';
    }

    /**
     * Alias of get_server_port().
     * Returns the port used by the server, or an empty string if not available.
     *
     * @return string The server port, or an empty string if not serving.
     */
    public static function get_port(): string
    {
        return self::get_server_port() ?? '';
    }

    /**
     * Alias of get_server_protocol().
     * Returns the protocol used by the server (e.g., HTTP/1.1), or an empty string if not available.
     *
     * @return string The server protocol, or an empty string if not serving.
     */
    public static function get_protocol(): string
    {
        return self::get_server_protocol() ?? '';
    }

    /**
     * Alias of get_remote_addr().
     * Returns the user's IP address, or an empty string if not available.
     *
     * @return string The remote (client) IP address, or an empty string if not serving.
     */
    public static function get_remote_ip(): string
    {
        return self::get_remote_addr();
    }

    /**
     * Alias of get_server_software().
     * Returns the software used by the server, or an empty string if not available.
     *
     * @return string The server software, or an empty string if not serving.
     */
    public static function get_software(): string
    {
        return self::get_server_software();
    }
}


/* FILE: ./Superglobals/PHPTraits/QueryTrait.php */

<?php

namespace PHP_Library\Superglobals\PHPTraits;

trait QueryTrait
{
    /**
     * Parse a query string into an array.
     *
     * @param string [optional] $query The query string to parse. If not given, it parses $_SERVER["QUERY_STRING"].
     *
     * @return array The parsed query as an array.
     */
    protected static function parse_query(?string $query = null): array
    {
        if (!$query) {
            $query = $_SERVER["QUERY_STRING"];
        }
        if ($query) {
            $return = [];
            $array = explode('&', $query);
            foreach ($array as $value) {
                if (strpos($value, '=')) {
                    $key_value = explode('=', $value);
                    $return[$key_value[0]] = urldecode($key_value[1]);
                } else {
                    $return[$value] = true;
                }
            }
            return $return;
        }
        return [];
    }
}


/* FILE: ./Superglobals/PHPTraits/RequestTrait.php */

<?php

namespace PHP_Library\Superglobals\PHPTraits;

use PHP_Library\Error\Error;
use PHP_Library\Superglobals\Server;

trait RequestTrait
{
    use QueryTrait;

    public static array $query;
    public static string $path;
    public static array $http_header;

    public static function get_http_header(): array
    {
        return static::$http_header = array_filter($_SERVER, function ($key) {
            return strpos($key, "HTTP_") === 0;
        }, ARRAY_FILTER_USE_KEY);
    }

    public static function get_http_header_field(string $name): string|bool
    {
        $php_server_field_name = "HTTP_" . str_replace("-", "_", strtoupper($name));
        return $_SERVER[$php_server_field_name] ?? false;
    }

    /**
     * Returns the path part of the request URI, without any query parameters.
     *
     * @return string The request URI path.
     */
    public static function get_path(): string
    {
        return static::$path = strtok(Server::get_request_uri(), '?') ?? '';
    }

    /**
     * Returns the query part of the request URI as array.
     *
     * @return array The Query data.
     */
    public static function get_query(): array
    {
        return static::$query = self::parse_query();
    }

    public static function get_query_field(string $name): int|string|array|false
    {
        if (!isset(static::$query)) {
            static::get_query();
        }
        if (!isset(static::$query[$name])) {
            return false;
        }
        return static::$query[$name];
    }
}


/* FILE: ./Superglobals/PHPTraits/ServerTrait.php */

<?php

namespace PHP_Library\Superglobals\PHPTraits;

/**
 * Trait Server
 *
 * A class that provides easy access to $_SERVER superglobal array elements
 * as static methods.
 */
trait ServerTrait
{
    /**
     * Returns the name of the server host (alternative method).
     *
     * @return string|false The value of $_SERVER['SERVER_NAME'] or false if not set.
     */
    public static function get_server_name(): string|bool
    {
        return $_SERVER['SERVER_NAME'] ?? false;
    }

    /**
     * Returns the request method used to access the page.
     *
     * @return string|false The value of $_SERVER['REQUEST_METHOD'] or false if not set.
     */
    public static function get_request_method(): string|bool
    {
        return $_SERVER['REQUEST_METHOD'] ?? false;
    }

    /**
     * Returns the IP address of the server.
     *
     * @return string|false The value of $_SERVER['SERVER_ADDR'] or false if not set.
     */
    public static function get_server_addr(): string|bool
    {
        return $_SERVER['SERVER_ADDR'] ?? false;
    }

    /**
     * Returns the Request Header "http content type" field.
     *
     * @return string|false The value of $_SERVER['CONTENT_TYPE'] or false if not set.
     */
    public static function get_content_type(): string|bool
    {
        return $_SERVER['CONTENT_TYPE'] ?? false;
    }


    /**
     * Returns the port on the server used by the web server for communication.
     *
     * @return string|false The value of $_SERVER['SERVER_PORT'] or false if not set.
     */
    public static function get_server_port(): string|bool
    {
        return $_SERVER['SERVER_PORT'] ?? false;
    }

    /**
     * Returns the software used by the server.
     *
     * @return string|false The value of $_SERVER['SERVER_SOFTWARE'] or false if not set.
     */
    public static function get_server_software(): string|bool
    {
        return $_SERVER['SERVER_SOFTWARE'] ?? false;
    }

    /**
     * Returns the server protocol used to communicate (e.g., HTTP/1.1).
     *
     * @return string|false The value of $_SERVER['SERVER_PROTOCOL'] or false if not set.
     */
    public static function get_server_protocol(): string|bool
    {
        return $_SERVER['SERVER_PROTOCOL'] ?? false;
    }

    /**
     * Returns the document root directory under which the current script is executing.
     *
     * @return string|false The value of $_SERVER['DOCUMENT_ROOT'] or false if not set.
     */
    public static function get_document_root(): string|bool
    {
        return $_SERVER['DOCUMENT_ROOT'] ?? false;
    }


    /**
     * Returns the user's IP address.
     *
     * @return string|false The value of $_SERVER['REMOTE_ADDR'] or false if not set.
     */
    public static function get_remote_addr(): string|bool
    {
        return $_SERVER['REMOTE_ADDR'] ?? false;
    }

    /**
     * Returns the host name or IP address of the client sending the request.
     *
     * @return string|false The value of $_SERVER['REMOTE_HOST'] or false if not set.
     */
    public static function get_remote_host(): string|bool
    {
        return $_SERVER['REMOTE_HOST'] ?? false;
    }

    /**
     * Returns the request URI which contains the path to the requested file or resource.
     *
     * @return string|false The value of $_SERVER['REQUEST_URI'] or false if not set.
     */
    public static function get_request_uri(): string|bool
    {
        return $_SERVER['REQUEST_URI'] ?? false;
    }

    /**
     * Returns the query string if it exists in the URL.
     *
     * @return string|false The value of $_SERVER['QUERY_STRING'] or false if not set.
     */
    public static function get_query_string(): string|bool
    {
        return $_SERVER['QUERY_STRING'] ?? false;
    }

    /**
     * Returns the HTTP referer (the URL from which the request was sent).
     *
     * @return string|false The value of $_SERVER['HTTP_REFERER'] or false if not set.
     */
    public static function get_http_referer(): string|bool
    {
        return $_SERVER['HTTP_REFERER'] ?? false;
    }

    /**
     * Returns the user agent string of the client's browser.
     *
     * @return string|false The value of $_SERVER['HTTP_USER_AGENT'] or false if not set.
     */
    public static function get_http_user_agent(): string|bool
    {
        return $_SERVER['HTTP_USER_AGENT'] ?? false;
    }

    /**
     * Returns the current script's filename.
     *
     * @return string|false The value of $_SERVER['SCRIPT_FILENAME'] or false if not set.
     */
    public static function get_script_filename(): string|bool
    {
        return $_SERVER['SCRIPT_FILENAME'] ?? false;
    }

    /**
     * Returns the current script's pathname relative to the document root.
     *
     * @return string|false The value of $_SERVER['SCRIPT_NAME'] or false if not set.
     */
    public static function get_script_name(): string|bool
    {
        return $_SERVER['SCRIPT_NAME'] ?? false;
    }

    /**
     * Returns the absolute pathname of the currently executing script.
     *
     * @return string|false The value of $_SERVER['PATH_TRANSLATED'] or false if not set.
     */
    public static function get_path_translated(): string|bool
    {
        return $_SERVER['PATH_TRANSLATED'] ?? false;
    }

    /**
     * Returns the timestamp of the start of the request.
     *
     * @return int|false The value of $_SERVER['REQUEST_TIME'] or false if not set.
     */
    public static function get_request_time(): int
    {
        return $_SERVER['REQUEST_TIME'] ?? false;
    }

    /**
     * Returns the client's port number.
     *
     * @return string|false The value of $_SERVER['REMOTE_PORT'] or false if not set.
     */
    public static function get_remote_port(): string|bool
    {
        return $_SERVER['REMOTE_PORT'] ?? false;
    }

    /**
     * Returns the current script's URI.
     *
     * @return string|false The value of $_SERVER['SCRIPT_URI'] or false if not set.
     */
    public static function get_script_uri(): string|bool
    {
        return $_SERVER['SCRIPT_URI'] ?? false;
    }
}


/* FILE: ./Superglobals/Get.php */

<?php

namespace PHP_Library\Superglobals;

use PHP_Library\Superglobals\PHPTraits\RequestTrait;

class Get
{
    use RequestTrait;
}


/* FILE: ./Superglobals/Post.php */

<?php

namespace PHP_Library\Superglobals;

use PHP_Library\Error\Warning;
use PHP_Library\Superglobals\PHPTraits\RequestTrait;

class Post
{
    use RequestTrait;

    static mixed $content;

    public static function has_content_type(string $name): bool
    {
        return $_SERVER['CONTENT_TYPE'] === $name;
    }

    public static function get_content_type(): string
    {
        return $_SERVER['CONTENT_TYPE'];
    }

    public static function get_content_field(string $key): mixed
    {
        if (! isset(static::$content)) {
            static::set_content();
        }
        if (!isset(static::$content[$key])) {
            Warning::trigger("Undefined Post Field '{$key}'");
            return null;
        }
        return static::$content[$key];
    }

    /**
     * Undocumented function
     *
     * @param string ...$key If multiple, it will check with AND-operator
     * @return boolean
     */
    public static function has_content_field(string ...$keys): bool
    {
        if (! isset(static::$content)) {
            static::set_content();
        }
        foreach ($keys as $key) {
            if (!isset(static::$content[$key])) {
                return false;
            }
        }
        return true;
    }

    protected static function set_content(): void
    {
        if (isset(static::$content)) {
            return;
        }

        if (self::get_content_type() === 'application/json') {
            $json = json_decode(file_get_contents("php://input"), true);
            static::$content = $json ? $json : [];
        }

        if (self::get_content_type() === 'multipart/form-data') {
            static::$content = array_merge($_POST, $_FILES);
        }
        static::$content = $_POST;
    }
}


/* FILE: ./Autoloader.php */

<?php

namespace PHP_Library;

use PHP_Library\Error\Error;

class Autoloader
{
    /**
     * @var string $includes_dir The directory path where non-`PHP_Library` classes are located.
     */
    private static string $includes_dir;

    /**
     * @var bool $initated Indicates whether the autoloader has been initiated (singleton pattern).
     */
    protected static bool $initated = false;

    /**
     * @var string $php_web_lib_dir The base directory path for the `PHP_Library` namespace classes.
     */
    private static string $php_web_lib_dir;

    /**
     * Constructs a `ClassAutoloader` singleton-instance.
     *
     * This constructor initializes the class autoloader for the `PHP_Library` namespace and
     * also allows loading of non-`PHP_Library` classes if they are located in the specified includes directory.
     *
     * @param string $includes_dir The directory where class files are located, relative to the project root.
     */
    public function __construct(string $includes_dir = 'inc')
    {
        // force singleton
        if (!self::$initated) {
            $php_web_lib_dir = dirname(__FILE__);
            self::$initated = self::init($php_web_lib_dir, $includes_dir);
        }
    }

    /**
     * Initializes the autoloader.
     *
     * This method sets up the autoloader for both `PHP_Library` classes and non-`PHP_Library` classes
     * within the specified directories. It cleans up the directory paths and registers the autoloader function.
     *
     * @param string $framework_dir The base directory of the `PHP_Library` framework.
     * @param string $includes_dir  The directory where non-`PHP_Library` class files are located.
     * @return bool Returns true if the autoloader was successfully registered.
     */
    public static function init(string $framework_dir, string $includes_dir): bool
    {
        // clean paths
        self::$includes_dir = rtrim($includes_dir, '/');
        self::$php_web_lib_dir = rtrim($framework_dir, '/');

        // register method
        return spl_autoload_register([__CLASS__, 'autoloader_function']);
    }

    /**
     * The autoloader function for loading classes.
     *
     * This function attempts to load a class by determining whether it belongs to the `PHP_Library` namespace
     * or is a non-`PHP_Library` class in the includes directory. It then calls the appropriate method to
     * generate the file path and include the class file.
     *
     * @param string $full_class_name The fully-qualified class name including the namespace.
     * @return bool Returns true if the class file was successfully included; otherwise, false.
     */
    private static function autoloader_function($full_class_name): bool
    {
        if (!self::is_class_in_namespace($full_class_name)) {
            return self::include(
                class_file: self::get_generic_class_file($full_class_name),
                full_class_name: $full_class_name,
                throw_error: false
            );
        }
        return self::include(
            class_file: self::get_php_lib_class_file($full_class_name),
            full_class_name: $full_class_name
        );
    }

    /**
     * Generates the file path for a non-`PHP_Library` class.
     *
     * This method returns the file path for a class that is not within the `PHP_Library` namespace,
     * based on the specified directory.
     *
     * @param string $full_class_name The fully-qualified class name including the namespace.
     * @return string The file path for the class.
     */
    private static function get_generic_class_file($full_class_name): string
    {
        return self::$includes_dir . DIRECTORY_SEPARATOR . self::replace_class_seperator($full_class_name) . '.php';
    }

    /**
     * Generates the file path for a `PHP_Library` class.
     *
     * This method returns the file path for a class that belongs to the `PHP_Library` namespace,
     * based on the `PHP_Library` base directory.
     *
     * @param string $full_class_name The fully-qualified class name excluding the `PHP_Library` namespace.
     * @return string The file path for the class within the `PHP_Library` directory.
     */
    private static function get_php_lib_class_file($full_class_name): string
    {
        // remove namespace-base name, because the dirname of the library can differ.
        $full_class_name = substr($full_class_name, strlen(__NAMESPACE__ . "\\"));
        // add dirname of library
        return self::$php_web_lib_dir . DIRECTORY_SEPARATOR . self::replace_class_seperator($full_class_name) . '.php';
    }

    /**
     * Includes the class file.
     *
     * This method includes the specified class file if it exists. If the file is not found, it throws an error.
     *
     * @param string $class_file The file path of the class to include.
     * @param string $full_class_name The fully-qualified name of the class.
     * @param bool $throw_error If true, the method will throw an Error...
     * @return bool Returns true if the file was successfully included.
     * @throws \Error if the class file is not found.
     */
    private static function include(string $class_file, string $full_class_name, bool $throw_error = true): bool
    {
        if (! file_exists($class_file)) {
            if ($throw_error) {
                throw new Error("Class '{$full_class_name}'-File '{$class_file}' not found.");
            }
            return false;
        }
        include $class_file;
        return true;
    }

    /**
     * Checks if a class belongs to the `PHP_Library` namespace.
     *
     * @param string $full_class_name The fully-qualified class name including the namespace.
     * @return string Returns an integer as a string if the class is in the `PHP_Library` namespace; otherwise, false.
     */
    public static function is_class_in_namespace($full_class_name): string
    {
        return is_int(strpos($full_class_name, __NAMESPACE__));
    }

    /**
     * Replaces the namespace separators with directory separators.
     *
     * @param string $class_name The class name with namespace
     * @return string The class name with directory separators
     */
    private static function replace_class_seperator(string $class_name): string
    {
        return str_replace("\\", DIRECTORY_SEPARATOR, $class_name);
    }
}


/* FILE: ./Router/Router.php */

<?php

namespace  PHP_Library\Router;

use PHP_Library\ClassTraits\SingletonPattern;
use PHP_Library\Router\EndpointTypes\Redirect;
use PHP_Library\Router\Error\RouterError;
use PHP_Library\Router\HTMLResponse\HTMLDoc;
use PHP_Library\Superglobals\Get;
use PHP_Library\Superglobals\Server;

class Router
{
    use SingletonPattern;

    public static array $endpoints = [];
    protected static array $html_templates = [];
    public static Endpoint $current_endpoint;

    public static function add_endpoint(Endpoint &$endpoint)
    {
        self::init_singleton();
        $method = strtoupper($endpoint->http_method);
        if (isset(self::$endpoints[$method][$endpoint->path])) {
            throw new RouterError("Endpoint {$method} '{$endpoint}' is already set.");
        }
        self::$endpoints[$method][$endpoint->path] = $endpoint;
    }

    public static function add_html_template(string $path, string $regex = ".*")
    {
        self::$html_templates[$regex] = $path;
    }

    public static function redirect_now(string $location, array $query_data = []): void
    {
        if (headers_sent()) {
            throw new RouterError("Can not trigger redirect after headers been sent.");
        }
        $redirect_endpoint = new Redirect(Router::$current_endpoint->path, $location);
        $redirect_endpoint->add_query_data($query_data);
        static::$current_endpoint = $redirect_endpoint;
        die();
    }

    private function __construct()
    {
        if (Server::is_serving_http()) {
            header_register_callback(function () {
                static::php_header_callback();
            });
        }
    }

    public function __destruct()
    {
        $content = static::current_endpoint()->get_content();
        $status_code = static::current_endpoint()->status_code;
        if ($content === false) {
            $content = "Endpoint registred but no get_content().";
            $status_code = 500;
        }
        self::send_status_code($status_code);
        print(self::decode_content($content));
        exit();
    }

    protected static function decode_content(mixed $content): string
    {
        $client_accept_header = explode(',', Get::get_http_header_field('accept'));
        switch ($client_accept_header[0]) {
            case 'text/html':
                return self::get_html_doc($content);
                break;

            case 'application/json':
                return json_encode($content);

            case 'application/xml':
                return xmlrpc_encode($content);

            default:
                return (string) $content;
        }
    }

    protected static function get_html_doc($content): string
    {
        foreach (self::$html_templates as $regex => $path) {
            if (preg_match($regex, Get::get_path())) {
                HTMLDoc::set_template_file($path);
            }
        }
        return HTMLDoc::get_rendered($content);
    }

    protected static function php_header_callback()
    {
        foreach (static::current_endpoint()->http_headers as $field => $value) {
            if (is_array($value)) {
                $value = rtrim(implode(';', $value), ";");
            }
            header("$field: $value");
        }
    }

    private static function current_endpoint(): Endpoint
    {
        if (isset(self::$current_endpoint)) {
            return self::$current_endpoint;
        }
        $path = Get::get_path();
        $method = Server::get_request_method();
        if (! isset(self::$endpoints[$method][$path])) {
            throw new RouterError("No Route for $method '$path' defined.");
        }
        self::$current_endpoint = self::$endpoints[$method][$path];
        return self::$current_endpoint;
    }

    private static function send_status_code(int $code, string $message = ''): void
    {
        if (headers_sent()) {
            throw new RouterError("Headers already sent.");
        }
        http_response_code($code);
        header(Server::get_protocol() . " " . trim("$code $message"));
    }
}


/* FILE: ./Router/Error/RouterError.php */

<?php

namespace PHP_Library\Router\Error;

use PHP_Library\Router\EndpointTypes\Callback;
use PHP_Library\Router\Router;
use PHP_Library\Superglobals\Get;
use Throwable;

class RouterError extends \PHP_Library\Error\Error
{
    public function __construct(string $message = "", int $http_code = 500, ?Throwable $previous = null)
    {
        if (!isset(Router::$current_endpoint)) {
            Router::$current_endpoint = new Callback(Get::get_path(), function () use ($message) {
                return "<pre>{$message}</pre>";
            });
        }
        Router::$current_endpoint->add_http_header('x-error', $message)->status_code = $http_code;
        parent::__construct($message, $http_code, $previous);
    }
}


/* FILE: ./Router/Endpoint.php */

<?php

namespace  PHP_Library\Router;

use PHP_Library\Element\Element;
use PHP_Library\Router\EndpointTypes\Callback;
use PHP_Library\Router\EndpointTypes\PHPFile;
use PHP_Library\Router\EndpointTypes\Redirect;
use PHP_Library\Router\EndpointTypes\TextFile;
use Stringable;

abstract class Endpoint implements Stringable
{
    public string $path;

    public string $http_method;

    public array $http_headers = [];

    public int $status_code = 200;

    protected string $title;

    abstract protected function constructor(mixed $content): static;

    abstract public function get_content(): string|false;

    static function new_callback_endpoint(string $path, callable $function, string $http_method = 'get'): Callback
    {
        return new Callback($path, $function, $http_method);
    }

    static function new_php_file_endpoint(string $path, string $file, string $http_method = 'get'): PHPFile
    {
        return new PHPFile($path, $file, $http_method);
    }

    static function new_redirect_endpoint(string $path, string|Endpoint $location, int $code = 301, string $http_method = 'get'): Redirect
    {
        $endpoint = new Redirect($path, $location, $http_method);
        $endpoint->status_code = $code;
        return $endpoint;
    }

    static function new_text_file_endpoint(string $path, string $file, string $http_method = 'get'): TextFile
    {
        return new TextFile($path, $file, $http_method);
    }

    public function __construct(string $path, mixed $content, $http_method = 'get')
    {
        $this->path = str_starts_with($path, '/') ? $path : "/$path";
        $this->http_method = $http_method;
        $this->constructor($content);
        Router::add_endpoint($this);
    }

    public function add_http_header($field, $value): static
    {
        $this->http_headers[$field] = $value;
        return $this;
    }

    public function get_link(?string $text = null): Element
    {
        if ($text) {
            return new Element('a', ['href' => $this->path], $text);
        }
        if (isset($this->title)) {
            return new Element('a', ['href' => $this->path], $this->title);
        }
        return new Element('a', ['href' => $this->path], '@');
    }

    public function set_title(string $title): static
    {
        $this->title = $title;
        return $this;
    }

    public function get_title(): string
    {
        return $this->title ?? '';
    }

    public function __toString(): string
    {
        return $this->path;
    }

    protected static function get_abs_path(string $path): string
    {
        if (! str_starts_with('/', $path)) {
            return $_SERVER['DOCUMENT_ROOT'] . "/{$path}";
        }
        return $path;
    }
}


/* FILE: ./Router/EndpointTypes/Redirect.php */

<?php

namespace PHP_Library\Router\EndpointTypes;

use PHP_Library\Error\Error;
use PHP_Library\Router\Endpoint;
use PHP_Library\Router\Error\RouterError;

/**
 * the 'content' is the location, the 'path' is the path. so we redirect from the path to the location.
 * @package PHP_Library\Router\EndpointTypes
 */
class Redirect extends Endpoint
{
    public function get_content(): string
    {
        return '';
    }

    protected function constructor(mixed $location): static
    {
        $this->status_code = 302;
        if (is_object($location)) {
            if (is_subclass_of($location, get_parent_class($this))) {
                $location =  $location->path;
            } else {
                throw new RouterError("\$location is not an Endpoint");
            }
        } elseif (!is_string($location)) {
            throw new RouterError("\$location is not a string");
        }
        $this->http_headers['location'] = $location;
        return $this;
    }

    public function add_query_data(array $data): static
    {
        if (empty($data)) {
            return $this;
        }
        $url = $this->http_headers['location'];
        if (is_int(strpos($url, '?'))) {
            $url .= "&" . http_build_query($data);
        } else {
            $url .= "?" . http_build_query($data);
        }
        $this->http_headers['location'] = $url;
        return $this;
    }
}


/* FILE: ./Router/EndpointTypes/Callback.php */

<?php

namespace PHP_Library\Router\EndpointTypes;

use PHP_Library\Error\Error;
use PHP_Library\Router\Endpoint;

class Callback extends Endpoint
{
    private array $callback = [];

    public function get_content(): string
    {
        $content = call_user_func($this->callback[0]);
        if (!is_string($content)) {
            throw new Error("\$callback must return string");
        }
        return $content;
    }

    protected function constructor(mixed $callback): static
    {
        if (!is_callable($callback)) {
            throw new Error("\$callback is not callable");
        }
        $this->callback = [0 => $callback];
        return $this;
    }
}


/* FILE: ./Router/EndpointTypes/TextFile.php */

<?php

namespace PHP_Library\Router\EndpointTypes;

use PHP_Library\Router\Endpoint;
use PHP_Library\Superglobals\Server;

class TextFile extends Endpoint
{
    private string $file;

    public array $http_headers = [
        'content-type' => ['text/html', 'charset' => 'utf-8']
    ];

    public function get_content(): string|false
    {
        return @file_get_contents($this->file);
    }

    protected function constructor(mixed $file): static
    {
        $file =  static::get_abs_path($file);
        $this->file = $file;
        return $this;
    }
}


/* FILE: ./Router/EndpointTypes/Attachment.php */

<?php

namespace PHP_Library\Router\EndpointTypes;

use PHP_Library\Error\Error;
use PHP_Library\Router\Endpoint;

class Attachment extends Endpoint
{
    private string $file;

    public function get_content(): string
    {
        ???
    }

    protected function constructor(mixed $file): static
    {
        if (!is_file($file)) {
            throw new Error("\$file is not a file");
        }
        $this->file = $file;
        return $this;
    }
}


/* FILE: ./Router/EndpointTypes/PHPFile.php */

<?php

namespace PHP_Library\Router\EndpointTypes;

use PHP_Library\Error\Error;
use PHP_Library\Router\Endpoint;

class PHPFile extends Endpoint
{
    private string $file;

    private array $vars = [];

    public array $http_headers = [
        'content-type' => ['text/html', 'charset' => 'utf-8']
    ];

    public function add_variable(string $name, mixed $value): static
    {
        $this->vars[$name] = $value;
        return $this;
    }

    public function get_content(): string
    {
        ob_start();
        foreach ($this->vars as $var_name => $value) {
            $$var_name = $value;
        }
        require $this->file;
        return ob_get_clean();
    }

    protected function constructor(mixed $file): static
    {
        $file =  static::get_abs_path($file);
        if (!is_file($file)) {
            throw new Error("\$file is not a file");
        }
        $this->file = $file;
        return $this;
    }
}


/* FILE: ./Router/HTMLResponse/default_html_template.php */

<!DOCTYPE html>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Title</title>
</head>

<body>
    <?= $content ?>
</body>

</html>


/* FILE: ./Router/HTMLResponse/HTMLDoc.php */

<?php

namespace PHP_Library\Router\HTMLResponse;

use PHP_Library\Error\Error;
use PHP_Library\Router\Router;
use PHP_Library\Superglobals\Get;

class HTMLDoc
{
    static protected array $template_files = [];

    static protected string $default_template_file = __DIR__ . '/default_html_template.php';

    protected static array $overwrite_content = [
        'head' => [],
        'body' => []
    ];

    static public function get_rendered(string $content, mixed ...$variable): string
    {
        $variable['content'] = $content;
        extract($variable);
        ob_start();
        $template_file = static::get_matching_templatefile();
        include $template_file;
        $html_doc = ob_get_clean();
        if ($endpoint_title = Router::$current_endpoint->get_title()) {
            static::$overwrite_content['head']['title'] = $endpoint_title;
        }
        $html_doc = static::overwrite_singular_tag($html_doc, 'title');
        $html_doc = static::append_repetitive_tag($html_doc, 'meta');
        $html_doc = static::append_repetitive_tag($html_doc, 'style');
        $html_doc = static::append_repetitive_tag($html_doc, 'script');
        $html_doc = static::overwrite_singular_tag($html_doc, 'base');
        $html_doc = static::append_repetitive_tag($html_doc, 'link');
        return $html_doc;
    }

    /**
     * set template file. to populate it with content, use the `$content` variable inside the file.
     *
     * @param string $path
     * @return void
     */
    public static function set_template_file(string $path, string $preg_pattern = '/.*/'): void
    {
        if (!str_starts_with($path, '/')) {
            $path = $_SERVER['DOCUMENT_ROOT'] . "/{$path}";
        }

        array_unshift(static::$template_files, [
            'preg_pattern' => $preg_pattern,
            'file' => $path
        ]);
    }

    // only one title elem per html doc
    public static function set_title(string $title): void
    {
        static::$overwrite_content['head']['title'] = $title;
    }

    public static function add_style(string $css): void
    {
        if (!isset(static::$overwrite_content['head']['style'])) {
            static::$overwrite_content['head']['style'] = [];
        }
        array_push(static::$overwrite_content['head']['style'], $css);
    }

    public static function add_script(string $js): void
    {
        if (!isset(static::$overwrite_content['head']['script'])) {
            static::$overwrite_content['head']['script'] = [];
        }
        array_push(static::$overwrite_content['head']['script'], $js);
    }

    // only one base elem per html doc
    public static function set_base(array $attributes): void
    {
        static::$overwrite_content['head']['base'] = $attributes;
    }

    public static function add_meta(array $attributes): void
    {
        if (!isset(static::$overwrite_content['head']['meta'])) {
            static::$overwrite_content['head']['meta'] = [];
        }
        array_push(static::$overwrite_content['head']['meta'], $attributes);
    }

    public static function add_link(array $attributes): void
    {
        if (!isset(static::$overwrite_content['head']['link'])) {
            static::$overwrite_content['head']['link'] = [];
        }
        array_push(static::$overwrite_content['head']['link'], $attributes);
    }

    protected static function append_repetitive_tag(string $html_doc, string $tag_name): string
    {
        if (! isset(static::$overwrite_content['head'][$tag_name])) {
            return $html_doc;
        }
        $new_tags = '';
        foreach (static::$overwrite_content['head'][$tag_name] as $key => $content) {
            if (is_array($content)) {
                $new_tags .= static::create_singular_tag($tag_name, $content) . PHP_EOL;
            } else {
                $new_tags .= "<{$tag_name}>{$content}</{$tag_name}>" . PHP_EOL;
            }
        }
        $current_tags = [];
        if (
            preg_match_all('/<' . $tag_name . '.*?<\/' . $tag_name . '>/', $html_doc, $current_tags)
            || preg_match_all('/<' . $tag_name . '.*?>/', $html_doc, $current_tags)
        ) {
            $last_tag = end($current_tags[0]);
            return str_replace(
                $last_tag,
                $last_tag . PHP_EOL . $new_tags,
                $html_doc
            );
        }
        return str_replace(
            "</head>",
            $new_tags . "</head>",
            $html_doc
        );
    }

    protected static function overwrite_singular_tag(string $html_doc, string $tag_name): string
    {
        if (! isset(static::$overwrite_content['head'][$tag_name])) {
            return $html_doc;
        }
        return preg_replace(
            '/<' . $tag_name . '>(.*?)<\/' . $tag_name . '>/i',
            static::create_singular_tag($tag_name),
            $html_doc
        );
    }

    protected static function create_singular_tag(string $tag_name, ?array $attributes = null): string
    {
        // new attributes
        $opening_tag = "<{$tag_name}";
        if (! is_null($attributes)) {
            foreach ($attributes as $key => $value) {
                $opening_tag .= " {$key}=\"{$value}\"";
            }
        } else {
            if (is_array(static::$overwrite_content['head'][$tag_name])) {
                foreach (static::$overwrite_content['head'][$tag_name] as $key => $value) {
                    $opening_tag .= " {$key}=\"{$value}\"";
                }
            }
        }

        $tag = $opening_tag . '>';
        // new content
        if (is_string(static::$overwrite_content['head'][$tag_name])) {
            $tag .= htmlspecialchars(static::$overwrite_content['head'][$tag_name]) . "</{$tag_name}>";
        }
        return $tag;
    }

    public static function get_matching_templatefile(): string
    {
        if (empty(static::$template_files)) {
            return static::$default_template_file;
        }
        $path = Get::get_path();
        foreach (static::$template_files as $template_file) {
            if (false === preg_match($template_file['preg_pattern'], $path, $matches)) {
                throw new Error("Invalid preg pattern: '{$template_file['preg_pattern']}'");
            }
            if ($matches) {
                return $template_file['file'];
            }
        }
        return static::$default_template_file;
    }
}


/* FILE: ./Router/ResponseTraits/HTTPData.php */

<?php

namespace  PHP_Library\Router\ResponseTraits;

trait HTTPData
{
    public function articulate(): void
    {
        $file_size = filesize($this->path);
        $file_date = date('r', filemtime($this->path));

        $file = @fopen($this->path, 'rb');
        if (!$file) {
            header("HTTP/1.0 505 Internal server error");
            return;
        }

        $file_position = 0;
        $file_end = $file_size;

        if (isset($_SERVER['HTTP_RANGE'])) {
            if (preg_match('/bytes=\h*(\d+)-(\d*)[\D.*]?/i', $_SERVER['HTTP_RANGE'], $matches)) {
                $file_position = intval($matches[0]);
                if (!empty($matches[1]))
                    $file_end = intval($matches[1]);
            }
        }

        if ($file_position > 0 || $file_end < $file_size)
            header('HTTP/1.0 206 Partial Content');
        else
            header('HTTP/1.0 200 OK');

        header("Content-Type: $this->mime_type");
        header('Cache-Control: public, must-revalidate, max-age=0');
        header('Pragma: no-cache');
        header('Accept-Ranges: bytes');
        header('Content-Length:' . ($file_end - $file_position));
        header("Content-Range: bytes $file_position-$file_end/$file_size");
        header("Content-Disposition: inline; filename='" . basename($this->path) . "'");
        header("Content-Transfer-Encoding: binary\n");
        header("Last-Modified: $file_date");
        header('Connection: close');

        fseek($file, $file_position, 0);
        while (!feof($file) && $file_position < $file_end && (connection_status() == 0)) {
            print fread($file, min(1024 * 16, $file_end - $file_position));
            $file_position += 1024 * 16;
        }
    }
}


/* FILE: ./Router/ResponseTraits/CLIText.php */

<?php

namespace  PHP_Library\Router\ResponseTraits;

trait CLIText
{
    public function articulate(): void {}
}


/* FILE: ./Router/ResponseTraits/HTTPText.php */

<?php

namespace  PHP_Library\Router\ResponseTraits;

trait HTTPText
{
    public function articulate(): void
    {
        echo $this;
    }
}


/* FILE: ./MarkdownParser/MarkdownParser.php */

<?php

namespace PHP_Library\MarkdownParser;

class MarkdownParser
{
    static ?int $list_counter = null;
    static ?string $list_type = null;

    static public function to_html(string $markdown): string
    {
        $html = '';

        // things that start with a symbol at row-start
        foreach (explode(PHP_EOL, $markdown) as $row) {
            if (is_int(static::$list_counter)) {
                if (str_starts_with($row, static::$list_counter = static::$list_counter + 1 . ". ")) {
                    $html .= "<li>" . substr($row, 3) . "</li>" . PHP_EOL;
                    continue;
                } else {
                    $html .= PHP_EOL . "</" . static::$list_type . ">" . PHP_EOL;
                    static::$list_counter = null;
                    static::$list_type = null;
                }
            }
            if (str_starts_with($row, '# ')) {
                $html .= "<h1>" . substr($row, 2) . "</h1>" . PHP_EOL;
                continue;
            }
            if (str_starts_with($row, '## ')) {
                $html .= "<h2>" . substr($row, 3) . "</h2>" . PHP_EOL;
                continue;
            }
            if (str_starts_with($row, '### ')) {
                $html .= "<h3>" . substr($row, 4) . "</h3>" . PHP_EOL;
                continue;
            }
            if (str_starts_with($row, '#### ')) {
                $html .= "<h4>" . substr($row, 5) . "</h4>" . PHP_EOL;
                continue;
            }
            if (str_starts_with($row, '##### ')) {
                $html .= "<h5>" . substr($row, 6) . "</h5>" . PHP_EOL;
                continue;
            }
            if (str_starts_with($row, '###### ')) {
                $html .= "<h6>" . substr($row, 7) . "</h6>" . PHP_EOL;
                continue;
            }
            if (str_starts_with($row, '> ')) {
                $html .= "<blockquote><p>" . substr($row, 2) . "</p></blockquote>" . PHP_EOL;
                continue;
            }
            if (str_starts_with($row, '1. ')) {
                static::$list_counter = 1;
                static::$list_type = 'ol';
                $html .= "<ol>" . PHP_EOL . "<li>" . substr($row, 3) . "</li>" . PHP_EOL;
                continue;
            }
            if (str_starts_with($row, '- ')) {
                static::$list_counter = 1;
                static::$list_type = 'ul';
                $html .= "<ul>" . PHP_EOL . "<li>" . substr($row, 3) . "</li>" . PHP_EOL;
                continue;
            }
            if (!trim($row)) {
                continue;
            }
            $html .= "<p>{$row}.</p>";
        }

        // things that appear somewhere in a line
        $html = preg_replace('/(\*\*\*(.*?)\*\*\*)/', '<b>$2</b>', $html);
        $html = preg_replace('/(\*(.*?)\*)/', '<i>$2</i>', $html);
        $html = preg_replace('/(`(.*?)`)/', '<code>$2</code>', $html);
        $html = preg_replace('/\[(.*?)\]\((.*)\)/', '<a href="$2">$1</a>', $html);
        return $html;
    }
}


/* FILE: ./Utils/Convert.php */

<?php

namespace  PHP_Library\Utils;

class Convert
{
    public static function iso8601_to_seconds(string $iso8601_input): int
    {
        $regex        = "/^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/";
        preg_match('/\d{1,2}[H]/', $iso8601_input, $hours);
        preg_match('/\d{1,2}[M]/', $iso8601_input, $minutes);
        preg_match('/\d{1,2}[S]/', $iso8601_input, $seconds);

        $duration = [
            'hours'   => $hours ? (int) $hours[0] : 0,
            'minutes' => $minutes ? (int) $minutes[0] : 0,
            'seconds' => $seconds ? (int) $seconds[0] : 0,
        ];

        $toltalSeconds = ($duration['hours'] * 60 * 60) + ($duration['minutes'] * 60) + $duration['seconds'];
        return $toltalSeconds;
    }
}



function details_of_videos__youtube_filter(array $video_details): array
{
    $video_details = $video_details['items'][0];
    return [
        'duration' => Convert::iso8601_to_seconds($video_details['contentDetails']['duration']),
        'title' => $video_details['snippet']['title'],
        'id' => $video_details["id"]
    ];
}

/* FILE: ./Types/StringType.php */

<?php

namespace  PHP_Library\Types;

use PHP_Library\Types\BaseTypeTraits\PHPStringFunctions;

class StringType extends AbstractType implements \Stringable
{
    use PHPStringFunctions;

    protected string $encoding = 'UTF-8';

    public function __construct(protected mixed $value = '')
    {
        $this->value = $value;
    }

    /**
     * Convert the string to a plain string.
     *
     * @return string
     */
    public function __toString(): string
    {
        return (string) $this->value;
    }

    /**
     * Mutator Methods
     *
     * - These methods modify the content of the current StringType instance. They are used to perform various string manipulation operations.
     * - They include methods to prepend a string, append a string,
     *       remove a specific string from the content, add or remove lines, repeat the string, trim whitespace, create a text box around the string, and apply padding.
     * - These methods are used for changing the content of the string and are crucial for string processing and formatting.
     */

    /**
     * Prepend a string to the beginning of the current string.
     *
     * @param string $string The string to prepend.
     *
     * @return static
     */
    public function prepend(string $string): static
    {
        $this->value = $string . $this->value;
        return $this;
    }

    /**
     * Append a string to the end of the current string.
     *
     * @param string $string The string to append.
     *
     * @return static
     */
    public function append(string $string): static
    {
        $this->value .= $string;
        return $this;
    }

    /**
     * Remove a specific string from the current string.
     *
     * @param string|array $substring The value getting removed. An array may to used to remove multiple substrings.
     *
     * @return static
     */
    public function remove_substring(string|array $substring, bool $case_sensetive = true, int &$count): static
    {
        return $this->replace_substring($substring, '', $case_sensetive, $count);
    }

    /**
     * Remove a string from the start of the current string.
     *
     * @param string $substring The string to remove from the start.
     *
     * @return static
     */
    public function remove_beginning_substring(string $substring): static
    {
        if ($this->has_beginning($substring)) {
            $this->get_substring(
                offset: StringType::len($substring)
            );
        }
        return $this;
    }

    final public static function make(self|string &$string): static
    {
        if (is_string($string)) {
            $string = new self($string);
        }
        return $string;
    }

    /**
     * Surround the current string with another string.
     *
     * @param string|StringType $string The string to surround the current string with.
     *
     * @return static
     */
    public function surround(string|StringType $string): static
    {
        $this->value = $string . $this->value . StringType::rev($string);
        return $this;
    }
}


/* FILE: ./Types/StringExtensions/AnsiString.php */

<?php

namespace PHP_Library\Types\StringExtension;

use PHP_Library\Types\StringType;

class AnsiString extends StringType
{

    /**
     * ANSI Formatting Methods
     *
     * - These methods apply or remove ANSI escape sequences to the string, allowing for text formatting in terminals that support ANSI formatting.
     * - Methods like ansi_format_bold, ansi_format_italic, ansi_format_underline, ansi_format_strikethroug, and ansi_format_remove apply or remove text formatting styles.
     * - ANSI formatting is commonly used to emphasize or style text in command-line interfaces.
     */

    /**
     * Sanitize the current string by removing null characters
     *
     * @return StringType
     */
    public function remove_null_characters(): StringType
    {
        $this->value = str_replace("\x00", '', $this->value);
        return $this;
    }

    /**
     * Create a text box around the current string with optional title and padding.
     *
     * @param int $padding [optional] The amount of padding around the string content. Default is 4.
     * @param null|string|StringType $title [optional] The title for the box. Default is null.
     *
     * @return StringType
     */
    public function box_around_string(int $padding = 4, null|string|StringType $title = null): StringType
    {
        $top_left = "\xe2\x95\xad";
        $top_right = "\xe2\x95\xae";
        $btm_right = "\xe2\x95\xaf";
        $btm_left = "\xe2\x95\xb0";
        $horizontal = "\xe2\x94\x80";
        $vertical = "\xe2\x94\x82";

        $longest_line_length  = $this->get_longest_line()->get_length();
        if ($title) {
            $title = is_string($title) ? new StringType($title) : $title;
        }


        $box_string = new StringType();
        foreach ($this->get_lines() as $i => $line) {
            if (!$line->is_empty()) {
                $line->prepend($vertical . str_repeat(' ', $padding));
                $line->padding_right((1 + $padding + $longest_line_length) - $line->get_length())
                    ->append(str_repeat(' ', $padding) . $vertical);
                $box_string->append_line($line);
            }
        }

        if (!$title) {
            $top_border =  $top_left . str_repeat(
                string: $horizontal,
                times: $longest_line_length  + ($padding * 2)
            ) . $top_right;
        } else {
            if (($longest_line_length  + ($padding * 2) - $title->get_length()) < 0) {
                $top_border =  $title . PHP_EOL;
            } else {
                $top_border =  $title . str_repeat(
                    string: $horizontal,
                    times: $longest_line_length  +  1 + ($padding * 2) - $title->get_length()
                ) . $top_right;
            }
        }

        $bottom_border =  $btm_left . str_repeat(
            string: $horizontal,
            times: $longest_line_length  + ($padding * 2)
        ) . $btm_right;

        $this->value = $top_border . PHP_EOL . $box_string . PHP_EOL . $bottom_border . PHP_EOL;
        return $this;
    }




    /**
     * Apply bold ANSI formatting to the current string.
     *
     * @return StringType
     */
    public function format_bold(): StringType
    {

        $this->value = "\e[1m$this->value\e(B\e[m";
        return $this;
    }

    /**
     * Apply italic ANSI formatting to the current string.
     *
     * @return StringType
     */
    public function format_italic(): StringType
    {
        $this->value = "\e[3m$this->value\e(B\e[m";
        return $this;
    }

    /**
     * Apply underline ANSI formatting to the current string.
     *
     * @return StringType
     */
    public function format_underline(): StringType
    {
        $this->value = "\e[4m$this->value\e(B\e[m";
        return $this;
    }

    /**
     * Apply strikethrough ANSI formatting to the current string.
     *
     * @return StringType
     */
    public function format_strikethrough(): StringType
    {
        $this->value = "\e[9m$this->value\e(B\e[m";
        return $this;
    }

    /**
     * Remove ANSI formatting from the current string.
     *
     * @return StringType
     */
    public function format_remove(): StringType
    {
        $this->value = str_replace(
            [
                "\x00",
                "\e[1m",
                "\e[3m",
                "\e[4m",
                "\e[9m",
                "\e(B\e[m"
            ],
            '',
            $this->value
        );
        return $this;
    }

    /**
     * Get the length of the string.
     *
     * This method removes ANSI Control Characters before counting the length by default.
     *
     * @return int
     */
    public function get_clean_length(): int
    {
        $string = str_replace(
            [
                "\x00",
                "\e[1m",
                "\e[3m",
                "\e[4m",
                "\e[9m",
                "\e(B\e[m"
            ],
            '',
            $this->value
        );
        return mb_strlen($string, $this->encoding);
        $string_length;
    }
}


/* FILE: ./Types/BaseTypeTraits/PHPStringFunctions.php */

<?php

namespace PHP_Library\Types\BaseTypeTraits;

trait PHPStringFunctions
{
    /**
     * Alias of strtr
     *
     * Translate characters or replace substrings
     *
     * @param string $from The string replacing from.
     * @param string $to The string being translated to to.
     * @return static
     */
    final public function translate(string $from, string $to): static
    {
        $this->value = strtr($this->value, $from, $to);
        return $this;
    }

    /**
     * Static alias of strtr
     *
     * Translate characters or replace substrings
     *
     * @param string $string The string being translated.
     * @param string $from The string replacing from.
     * @param string $to The string being translated to to.
     * @return static
     */
    final static public function tr(string $string, string $from, string $to): static
    {
        return new self(strtr($string, $from, $to));
    }

    /**
     * Alias of strlen
     *
     * Get string length
     *
     * @return int The length of the string on success, and 0 if the string is empty.
     */
    final public function get_length(): int
    {
        return strlen($this->value);
    }

    /**
     * Static alias of strlen
     *
     * Get string length
     *
     * @param string $string The string being measured for length
     * @return int The length of the string on success, and 0 if the string is empty.
     */
    final static public function len(string $string): int
    {
        return strlen($string);
    }

    /**
     * Alias of strpos and stripos
     *
     * Find the position of the first occurrence of a substring in this string
     *
     * @param string $needle If needle is not a string, it is converted to an integer and applied as the ordinal value of a character.
     * @param int $offset If specified, search will start this number of characters counted from the beginning of the string.
     * @param bool $case_sensetive
     * @return int<0,max>|false
     * Returns the position where the needle exists relative to the beginning of this string (independent of search direction or offset).
     * Also note that string positions start at 0, and not 1.
     * Returns FALSE if the needle was not found.
     */
    final public function get_first_postion(mixed $needle, int $offset = 0, bool $case_sensitive = true): int|false
    {
        if ($case_sensitive) {
            return strpos($this->value, $needle, $offset);
        }
        return stripos($this->value, $needle, $offset);
    }

    /**
     * Static alias of strpos and stripos
     *
     * Find the position of the first occurrence of a substring in this string
     *
     * @param string $haystack The string to search in
     * @param string $needle If needle is not a string, it is converted to an integer and applied as the ordinal value of a character.
     * @param int $offset If specified, search will start this number of characters counted from the beginning of the string.
     * @param bool $case_sensetive
     * @return int<0,max>|false
     * Returns the position where the needle exists relative to the beginning of this string (independent of search direction or offset).
     * Also note that string positions start at 0, and not 1.
     * Returns FALSE if the needle was not found.
     */
    final static function pos(string $haystack, mixed $needle, $offset = 0, bool $case_sensitive = true): int|false
    {
        if ($case_sensitive) {
            return strpos($haystack, $needle, $offset);
        }
        return stripos($haystack, $needle, $offset);
    }

    /**
     * Alias of strrpos and strripos
     *
     * Find the position of the last occurrence of a substring in this string
     *
     * @param string $needle If needle is not a string, it is converted to an integer and applied as the ordinal value of a character.
     * @param int $offset If specified, search will start this number of characters counted from the beginning of the string.
     * If the value is negative, search will instead start from that many characters from the end of the string, searching backwards.
     * @param bool $case_sensetive
     * @return int<0,max>|false
     * Returns the position where the needle exists relative to the beginning of this string (independent of search direction or offset).
     * Also note that string positions start at 0, and not 1.
     * Returns FALSE if the needle was not found.
     */
    final public function get_last_postion(mixed $needle, int $offset = 0, bool $case_sensitive = true): int|false
    {
        if ($case_sensitive) {
            return strrpos($this->value, $needle, $offset);
        }
        return strripos($this->value, $needle, $offset);
    }

    /**
     * Static alias of strrpos and strripos
     *
     * Find the position of the last occurrence of a substring in this string
     *
     * @param string $haystack The string to search in
     * @param string $needle If needle is not a string, it is converted to an integer and applied as the ordinal value of a character.
     * @param int $offset If specified, search will start this number of characters counted from the beginning of the string.
     * If the value is negative, search will instead start from that many characters from the end of the string, searching backwards.
     * @param bool $case_sensetive
     * @return int<0,max>|false
     * Returns the position where the needle exists relative to the beginning of this string (independent of search direction or offset).
     * Also note that string positions start at 0, and not 1.
     * Returns FALSE if the needle was not found.
     */
    final static public function rpos(string $haystack, mixed $needle, int $offset = 0, bool $case_sensitive = true): int|false
    {
        if ($case_sensitive) {
            return strrpos($haystack, $needle, $offset);
        }
        return strripos($haystack, $needle, $offset);
    }

    /**
     * Alias of strrev
     *
     * Reverse a string
     *
     * @return static the reversed string.
     */
    final public function reverse(): static
    {
        $this->value = strrev($this->value);
        return $this;
    }

    /**
     * Static alias of strrev
     *
     * Reverse a string
     * @param string $string The string to be reversed.
     * @return static the reversed string.
     */
    final static public function rev(string $string): static
    {
        return new self(strrev($string));
    }

    /**
     * Alias of str_pad
     *
     * Pad a string to a certain length by adding another string repeating on the right.
     *
     * @param int<0,max> $str_length If the value of $str_length is negative, less than, or equal to the length of this string, no padding takes place.
     * @param string $pad_string The pad_string may be truncated if the required number of padding characters can't be evenly divided by the pad_string's length.
     * @return static The string with the length of $str_length.
     */
    final public function pad_right(int $str_length, string $pad_string = " "): static
    {
        $this->value = str_pad($this->value, $str_length, $pad_string, STR_PAD_RIGHT);
        return $this;
    }

    /**
     * Alias of str_pad
     *
     * Pad a string to a certain length by adding another string repeating on the left.
     *
     * @param int<0,max> $str_length If the value of $str_length is negative, less than, or equal to the length of this string, no padding takes place.
     * @param string $pad_string The pad_string may be truncated if the required number of padding characters can't be evenly divided by the pad_string's length.
     * @return static The string with the length of $str_length.
     */
    final public function pad_left(int $str_length, string $pad_string = " "): static
    {
        $this->value = str_pad($this->value, $str_length, $pad_string, STR_PAD_LEFT);
        return $this;
    }

    /**
     * Alias of str_pad
     *
     * Pad a string to a certain length by adding another string repeating on both sides.
     *
     * @param int<0,max> $str_length If the value of $str_length is negative, less than, or equal to the length of this string, no padding takes place.
     * @param string $pad_string The pad_string may be truncated if the required number of padding characters can't be evenly divided by the pad_string's length.
     * @return static The string with the length of $str_length.
     */
    final public function pad_both(int $str_length, string $pad_string = " "): static
    {
        $this->value = str_pad($this->value, $str_length, $pad_string, STR_PAD_BOTH);
        return $this;
    }

    /**
     * Static alias of str_pad
     *
     * Pad a string to a certain length by adding another string repeating on the right.
     *
     * @param string $string The input string.
     * @param int<0,max> $str_length If the value of $str_length is negative, less than, or equal to the length of this string, no padding takes place.
     * @param string $pad_string The pad_string may be truncated if the required number of padding characters can't be evenly divided by the pad_string's length.
     * @param int $pad_type Cn be STR_PAD_RIGHT, STR_PAD_LEFT, or STR_PAD_BOTH.
     * @return static The string with the length of $str_length.
     */
    final static public function pad(string $string, int $str_length, string $pad_string = " ", int $pad_type = STR_PAD_RIGHT): static
    {
        return new self(str_pad($string, $str_length, $pad_string, $pad_type));
    }

    /**
     * Alias of str_repeat
     *
     * Repeat a string
     *
     * @param int<0,max> $times Number of time the input string should be repeated. If the multiplier is set to 0, the function will return an empty string.
     * @return static — the repeated string.
     */
    final public function repeat($times): static
    {
        $this->value = str_repeat($this->value, $times);
        return $this;
    }

    /**
     * Alias of str_replace
     *
     * Replace all occurrences of the search string with the replacement string
     * @param string|string[] $substring The value being searched for, otherwise known as the needle. An array may be used to designate multiple needles.
     * @param string|string[] $replacement The replacement value that replaces found search values. An array may be used to designate multiple replacements.
     * @param bool $case_sensetive
     * @param int &$count If passed, this will be set to the number of replacements performed.
     * @return static This string  with the replaced values.
     */
    final public function replace_substring(array|string $substring, array|string $replacement, bool $case_sensetive = true, int &$count): static
    {
        if ($case_sensetive) {
            $this->value = str_replace($substring, $replacement, $this->value, $count);
        } else {
            $this->value = str_ireplace($substring, $replacement, $this->value, $count);
        }
        return $this;
    }

    /**
     * Static alias of str_replace
     *
     * Replace all occurrences of the search string with the replacement string
     * @param string $haystack The string being searched and replaced on.
     * @param string|string[] $needle The value being searched for, otherwise known as the needle. An array may be used to designate multiple needles.
     * @param string|string[] $replacement The replacement value that replaces found search values. An array may be used to designate multiple replacements.
     * @param bool $case_sensetive
     * @param int &$count If passed, this will be set to the number of replacements performed.
     * @return static A string  with the replaced values.
     */
    final public static function replace(string $haystack, array|string $needle, array|string $replacement, bool $case_sensetive = true,  &$count): static
    {
        if ($case_sensetive) {
            return new self(str_replace($needle, $replacement, $haystack, $count));
        }
        return new self(str_ireplace($needle, $replacement, $haystack, $count));
    }

    /**
     * Alias of str_shuffle
     *
     * Randomly shuffles a string
     *
     * @return static — the shuffled string.
     */
    final public function shuffle(): static
    {
        $this->value = str_shuffle($this->value);
        return $this;
    }

    /**
     * Alias of str_contains
     *
     * Checks if $substring is found in this string and returns a boolean value whether or not the $substring was found.
     *
     * @param string $substring
     * @return bool
     */
    final public function has_substring(string $substring): bool
    {
        return str_contains($this->value, $substring);
    }

    /**
     * Static alias of str_contains
     *
     * Checks if $needle is found in $haystack and returns a boolean value (true/false) whether or not the $needle was found.
     *
     * @param string $haystack
     * @param string $needle
     * @return bool
     */
    final public static function contains(string $haystack, string $needle): bool
    {
        return str_contains($haystack, $needle);
    }

    /**
     * Alias of str_split
     *
     * Convert a string to an array
     *
     * @param int<1,max> $length Maximum length of the chunk.
     * @return string[]|false The returned array will be broken down into chunks with each being split_length in length, FALSE is returned if split_length is less than 1.
     */
    final public function get_split_array(int $length = 1): array|false
    {
        return str_split($this->value, $length);
    }

    /**
     * Static alias of str_split
     *
     * Convert a string to an array
     *
     * @param string $string The input string.
     * @param int<1,max> $length Maximum length of the chunk.
     * @return string[]|false The returned array will be broken down into chunks with each being split_length in length, FALSE is returned if split_length is less than 1.
     */
    final static public function split(string $string, int $length = 1): array|false
    {
        return str_split($string, $length);
    }

    /**
     * Alias of explode
     *
     * Split a string by a string
     *
     * @param string $separator The boundary string, defaults to 'whitespace'
     * @param int $limit If limit is set and positive, the returned array will contain a maximum of limit elements with the last element containing the rest of string.
     * If the limit parameter is negative, all components except the last -limit are returned.
     * If the limit parameter is zero, then this is treated as 1.
     * @return string[]|false If delimiter is an empty string (""), explode will return false.
     * If delimiter contains a value that is not contained in string and a negative limit is used, then an empty array will be returned.
     * For any other limit, an array containing string will be returned.
     */
    final public function get_explode_array(string $separator = ' ', int $limit = PHP_INT_MAX): array
    {
        return explode($separator, $this->value, $limit);
    }

    /**
     * Static alias of explode
     *
     * Split a string by a string
     *
     * @param string $separator The boundary string.
     * @param string $string The input string.
     * @param int $limit If limit is set and positive, the returned array will contain a maximum of limit elements with the last element containing the rest of string.
     * If the limit parameter is negative, all components except the last -limit are returned.
     * If the limit parameter is zero, then this is treated as 1.
     * @return string[]|false If delimiter is an empty string (""), explode will return false.
     * If delimiter contains a value that is not contained in string and a negative limit is used, then an empty array will be returned.
     * For any other limit, an array containing string will be returned.
     */
    final static public function explode(string $separator, string $string, int $limit = PHP_INT_MAX): array
    {
        return explode($separator, $string, $limit);
    }

    /**
     * Alias of str_getcsv
     *
     * Parse this CSV string into an array
     *
     * @param string $separator Set the field delimiter (one character only).
     * @param string $enclosure Set the field enclosure character (one character only).
     * @param string $escape Set the escape character (one character only). Defaults as a backslash (\).
     * @return array an indexed array containing the fields read.
     */
    final public function get_csv_array(string $delimiter = ",", string $enclosure = '"', $escape = "\\"): array
    {
        return str_getcsv($this->value, $delimiter, $enclosure, $escape);
    }

    /**
     * Static alias of str_getcsv
     *
     * Parse a CSV string into an array
     *
     * @param string $string The string to parse.
     * @param string $separator Set the field delimiter (one character only).
     * @param string $enclosure Set the field enclosure character (one character only).
     * @param string $escape Set the escape character (one character only). Defaults as a backslash (\).
     * @return array an indexed array containing the fields read.
     */
    final static public function getcsv(string $string, string $delimiter = ",", string $enclosure = '"', $escape = "\\"): array
    {
        return str_getcsv($string, $delimiter, $enclosure, $escape);
    }

    /**
     * Alias of json_decode
     *
     * Parse this JSON string into an array
     * @param int $flags Bitmask consisting of
     * JSON_HEX_QUOT,JSON_HEX_TAG,JSON_HEX_AMP,JSON_HEX_APOS,JSON_NUMERIC_CHECK,JSON_PRETTY_PRINT,JSON_UNESCAPED_SLASHES,JSON_FORCE_OBJECT,JSON_UNESCAPED_UNICODE.JSON_THROW_ON_ERROR
     * The behaviour of these constants is described on the JSON constants page.
     * @param int<1,max> $depth Set the maximum depth. Must be greater than zero.
     * @return array a Jarray representation of JSON data on success or FALSE on failure.
     */
    final public function get_json_array(int $depth = 512, int $flags = 0): array|false
    {
        return json_decode($this->value, true, $depth, $flags);
    }

    /**
     * Alias of strtolower
     *
     * Make a string lowercase
     * @return static — the lowercased string.
     */
    final public function lower_case(): static
    {
        $this->value = strtolower($this->value);
        return $this;
    }

    /**
     * Static alias of strtolower
     *
     * Make a string lowercase
     * @param string $string The input string.
     * @return static The lowercased string.
     */
    final public function tolower(string $string): static
    {
        return new self(strtolower($string));
    }

    /**
     * Alias of strtoupper
     *
     * Make a string uppercase
     * @return static The uppercased string.
     */
    final public function upper_case(): static
    {
        $this->value = strtoupper($this->value);
        return $this;
    }

    /**
     * Static alias of strtoupper
     *
     * Make a string uppercase
     * @param string $string The input string.
     * @return static The uppercased string.
     */
    final public function toupper(string $string): static
    {
        return new self(strtoupper($string));
    }

    /**
     * Alias of str_starts_with
     *
     * The function returns true if this string starts from the $substring string or false otherwise.
     *
     * @param string $substring
     * @return bool
     */
    final public function has_beginning(string $substring): bool
    {
        return str_starts_with($this->value, $substring);
    }

    /**
     * Static alias of str_starts_with
     *
     * The function returns true if the passed $haystack starts from the $needle string or false otherwise.
     *
     * @param string $haystack
     * @param string $needle
     * @return bool
     */
    final public static function starts_with(string $haystack, string $needle): bool
    {
        return str_starts_with($haystack, $needle);
    }

    /**
     * Alias of str_ends_with
     *
     * The function returns true if this string ends with the $substring string or false otherwise.
     *
     * @param string $substring
     * @return bool
     */
    final public function has_ending(string $substring): bool
    {
        return str_ends_with($this->value, $substring);
    }

    /**
     * Static alias of str_ends_with
     *
     * The function returns true if the passed $haystack ends with the $needle string or false otherwise.
     *
     * @param string $haystack
     * @param string $needle
     * @return bool
     */
    final public static function ends_with(string $haystack, string $needle): bool
    {
        return str_ends_with($haystack, $needle);
    }

    /**
     * Alias of substr
     *
     * Return part of a string or empty string on failure.
     * @param int $offset If start is positve, the returned string will start at the start'th position in string, counting from zero.
     * If start is negative, the returned string will start at the start'th character from the end of string.
     * @param int $length If length is positive, the string returned will contain at most length characters beginning from start (depending on the length of string).
     * If length is given and is negative, then that many characters will be omitted from the end of string (after the start position has been calculated when a start is negative).
     * If start denotes a position beyond this truncation, an empty string will be returned.
     * If length is given and is 0, false or null an empty string will be returned.
     * @return static The substring
     */

    final public function get_substring(int $offset, ?int $length = null): static
    {
        return new self(substr($this->value, $offset, $length));
    }

    /**
     * Alias for trim
     *
     * Strip whitespace (or other characters) from the beginning and end of a string
     *
     * @param string $characters Characters to trim. Default is whitespace characters.
     *
     * @return static
     */
    public function trim(string $characters = " \t\n\r\0\x0B"): static
    {
        $this->value = trim($this->value, $characters);
        return $this;
    }

    /**
     * Alias for wordwrap
     *
     * Wraps a string to a given number of characters
     * @param int $max_length The number of characters at which the string will be wrapped.
     * @param bool $cut_long_words If the cut is set to true, the string is always wrapped at or before the specified width. So if you have a word that is larger than the given width, it is broken apart. (See second example).
     * @return static
     */
    public function word_wrap(int $max_length, bool $cut_long_words = true): static
    {
        $this->value = wordwrap(
            string: $this->value,
            width: $max_length,
            break: PHP_EOL,
            cut_long_words: $cut_long_words
        );
        return $this;
    }

    final public static function implode(array $array, string $separator = ""): static
    {
        return new self(implode($separator, $array));
    }
    // str_word_count() get_word_count
    // strtotime() get_timestamp
}


/* FILE: ./Types/BaseTypeTraits/PHPArrayFunctions.php */

<?php

namespace PHP_Library\Types\BaseTypeTraits;

trait PHPArrayFunctions
{
    /**
     * Converts all array keys to uppercase.
     *
     * Alias of `array_change_key_case` with `CASE_UPPER`.
     *
     * @return static Returns the instance with updated keys.
     */
    final public function key_case_to_upper(): static
    {
        $this->value = array_change_key_case($this->value, CASE_UPPER);
        return $this;
    }

    /**
     * Converts all array keys to lowercase.
     *
     * Alias of `array_change_key_case` with `CASE_LOWER`.
     *
     * @return static Returns the instance with updated keys.
     */
    final public function key_case_to_lower(): static
    {
        $this->value = array_change_key_case($this->value, CASE_LOWER);
        return $this;
    }

    /**
     * Changes the case of array keys in a new array.
     *
     * Static alias of `array_change_key_case`.
     *
     * @param array $array The input array.
     * @param int $case The case to convert keys to, `CASE_UPPER` or `CASE_LOWER`.
     * @return static Returns a new instance with the case-changed keys.
     */
    final static public function change_key_case(array $array, int $case = CASE_LOWER): static
    {
        return new self(array_change_key_case($array, $case));
    }

    /**
     * Splits an array into chunks.
     *
     * Alias of `array_chunk`.
     *
     * @param int $length The number of elements in each chunk.
     * @param bool $preserve_keys Whether to preserve the original array keys.
     * @return static Returns the instance with the array split into chunks.
     */
    final public function chunk(int $length, bool $preserve_keys = false): static
    {
        $this->value = array_chunk($this->value, $length, $preserve_keys);
        return $this;
    }

    /**
     * Splits an array into chunks and returns a new instance.
     *
     * Static alias of `array_chunk`.
     *
     * @param array $array The input array.
     * @param int $length The number of elements in each chunk.
     * @param bool $preserve_keys Whether to preserve the original array keys.
     * @return static Returns a new instance with the array split into chunks.
     */
    final static public function chunk_array(array $array, int $length, bool $preserve_keys = false): static
    {
        return new self(array_chunk($array, $length, $preserve_keys));
    }


    /**
     * Retrieves values from a single column in the array.
     *
     * Alias of `array_column`.
     *
     * @param string|int $column_key The column to retrieve.
     * @param string|int|null $index_key The column to use as the index for the returned array.
     * @return static Returns a new instance with the specified column values.
     */
    final public function get_column(string|int $column_key, string|int|null $index_key = null): static
    {
        return new self(array_column($this->value, $column_key, $index_key));
    }

    /**
     * Retrieves values from a single column in a new array.
     *
     * Static alias of `array_column`.
     *
     * @param array $array The input array.
     * @param string|int|null $column_key The column to retrieve.
     * @param string|int|null $index_key The column to use as the index for the returned array.
     * @return static Returns a new instance with the specified column values.
     */
    final static public function column(array $array, string|int|null $column_key, string|int|null $index_key = null): static
    {
        return new self(array_column($array, $column_key, $index_key));
    }

    /**
     * Reindexes an array using a specific column.
     *
     * Alias of `array_column` with `null` for the column value.
     *
     * @param string|int|null $index_key The column to use as the index for the returned array.
     * @return static Returns the instance with the array reindexed.
     */
    final public function reindex(string|int|null $index_key = null): static
    {
        $this->value = array_column($this->value, null, $index_key);
        return $this;
    }

    /**
     * Counts all the values of the array.
     *
     * Alias of `array_count_values`.
     *
     * @return static Returns a new instance with the counts of each value.
     */
    final public function get_values_count(): static
    {
        return new self(array_count_values($this->value));
    }

    /**
     * Counts all the values of a new array.
     *
     * Static alias of `array_count_values`.
     *
     * @param array $array The input array.
     * @return static Returns a new instance with the counts of each value.
     */
    final static public function count_values(array $array): static
    {
        return new self(array_count_values($array));
    }


    /**
     * Computes the difference between this array and other arrays.
     *
     * Alias of `array_diff`.
     *
     * @param array ...$array Arrays to compare against.
     * @return static Returns a new instance with the values that are present in the first array but not in the others.
     */
    final public function get_value_difference(array ...$array): static
    {
        return new self(array_diff($this->value, ...$array));
    }


    /**
     * Computes the difference between arrays.
     *
     * Static alias of `array_diff`.
     *
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to compare against.
     * @return static Returns a new instance with the values that are present in the first array but not in the others.
     */
    final static public function diff(array $array1, array ...$arrays): static
    {
        return new self(array_diff($array1, ...$arrays));
    }

    /**
     * Computes the difference between this array and other arrays with key association.
     *
     * Alias of `array_diff_assoc`.
     *
     * @param array ...$array Arrays to compare against.
     * @return static Returns a new instance with the values and keys that are present in the first array but not in the others.
     */
    final public function get_associative_difference(array ...$array): static
    {
        return new self(array_diff_assoc($this->value, ...$array));
    }


    /**
     * Computes the difference between arrays with key association.
     *
     * Static alias of `array_diff_assoc`.
     *
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to compare against.
     * @return static Returns a new instance with the values and keys that are present in the first array but not in the others.
     */
    final static public function diff_assoc(array $array1, array ...$arrays): static
    {
        return new self(array_diff_assoc($array1, ...$arrays));
    }

    /**
     * Computes the difference between this array and other arrays using keys.
     *
     * Alias of `array_diff_key`.
     *
     * @param array ...$array Arrays to compare against.
     * @return static Returns a new instance with the keys that are present in the first array but not in the others.
     */
    final public function get_key_difference(array ...$array): static
    {
        return new self(array_diff_key($this->value, ...$array));
    }

    /**
     * Computes the difference between arrays using keys.
     *
     * Static alias of `array_diff_key`.
     *
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to compare against.
     * @return static Returns a new instance with the keys that are present in the first array but not in the others.
     */
    final static public function diff_key(array $array1, array ...$arrays): static
    {
        return new self(array_diff_key($array1, ...$arrays));
    }

    /**
     * Computes the intersection of this array and other arrays with values.
     *
     * Alias of `array_intersect`.
     *
     * @param array ...$array Arrays to intersect.
     * @return static Returns a new instance with the values that are present in all arrays.
     */
    final public function get_value_intersection(array ...$array): static
    {
        return new self(array_intersect($this->value, ...$array));
    }

    /**
     * Computes the intersection of arrays with values.
     *
     * Static alias of `array_intersect`.
     *
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to intersect.
     * @return static Returns a new instance with the values that are present in all arrays.
     */
    final static public function intersect(array $array1, array ...$arrays): static
    {
        return new self(array_intersect($array1, ...$arrays));
    }

    /**
     * Computes the intersection of this array and other arrays with key association.
     *
     * Alias of `array_intersect_assoc`.
     *
     * @param array ...$array Arrays to intersect.
     * @return static Returns a new instance with the values and keys that are present in all arrays.
     */
    final public function get_associative_intersection(array ...$array): static
    {
        return new self(array_intersect_assoc($this->value, ...$array));
    }

    /**
     * Computes the intersection of arrays with key association.
     *
     * Static alias of `array_intersect_assoc`.
     *
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to intersect.
     * @return static Returns a new instance with the values and keys that are present in all arrays.
     */
    final static public function intersect_assoc(array $array1, array ...$arrays): static
    {
        return new self(array_intersect_assoc($array1, ...$arrays));
    }


    /**
     * Computes the intersection of this array and other arrays using keys.
     *
     * Alias of `array_intersect_key`.
     *
     * @param array ...$array Arrays to intersect.
     * @return static Returns a new instance with the keys that are present in all arrays.
     */
    final public function get_key_intersection(array ...$array): static
    {
        return new self(array_intersect_key($this->value, ...$array));
    }

    /**
     * Computes the intersection of arrays using keys.
     *
     * Static alias of `array_intersect_key`.
     *
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to intersect.
     * @return static Returns a new instance with the keys that are present in all arrays.
     */
    final static public function intersect_key(array $array1, array ...$arrays): static
    {
        return new self(array_intersect_key($array1, ...$arrays));
    }

    /**
     * Computes the difference of this array and other arrays using a user-defined comparison function.
     *
     * Alias of `array_udiff`.
     *
     * @param callable $value_compare_function The comparison function.
     * @param array ...$array Arrays to compare against.
     * @return static Returns a new instance with the array difference.
     */
    final public function get_custom_value_difference(callable $value_compare_function, array ...$array): static
    {
        $array[] = $value_compare_function;
        return new self(array_udiff($this->value, ...$array));
    }

    /**
     * Computes the difference of arrays using a user-defined comparison function.
     *
     * Static alias of `array_udiff`.
     *
     * @param callable $value_compare_function The comparison function.
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to compare against.
     * @return static Returns a new instance with the array difference.
     */
    final static public function udiff(callable $value_compare_function, array $array1, array ...$arrays): static
    {
        $arrays[] = $value_compare_function;
        return new self(array_udiff($array1, ...$arrays));
    }

    /**
     * Computes the difference of this array and other arrays with additional indexes compared using a user-defined comparison function.
     *
     * Alias of `array_udiff_assoc`.
     *
     * @param callable $value_compare_function The comparison function.
     * @param array ...$array Arrays to compare against.
     * @return static Returns a new instance with the associative array difference.
     */
    final public function get_custom_associative_difference(callable $value_compare_function, array ...$array): static
    {
        $array[] = $value_compare_function;
        return new self(array_udiff_assoc($this->value, ...$array));
    }

    /**
     * Computes the difference of arrays with additional indexes using a user-defined comparison function.
     *
     * Static alias of `array_udiff_assoc`.
     *
     * @param callable $value_compare_function The comparison function.
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to compare against.
     * @return static Returns a new instance with the associative array difference.
     */
    final static public function udiff_assoc(callable $value_compare_function, array $array1, array ...$arrays): static
    {
        $arrays[] = $value_compare_function;
        return new self(array_udiff_assoc($array1, ...$arrays));
    }

    /**
     * Computes the intersection of this array and other arrays using a user-defined comparison function.
     *
     * Alias of `array_uintersect`.
     *
     * @param callable $value_compare_function The comparison function.
     * @param array ...$array Arrays to compare against.
     * @return static Returns a new instance with the array intersection.
     */
    final public function get_custom_value_intersection(callable $value_compare_function, array ...$array): static
    {
        $array[] = $value_compare_function;
        return new self(array_uintersect($this->value, ...$array));
    }

    /**
     * Computes the intersection of arrays using a user-defined comparison function.
     *
     * Static alias of `array_uintersect`.
     *
     * @param callable $value_compare_function The comparison function.
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to compare against.
     * @return static Returns a new instance with the array intersection.
     */
    final static public function uintersect(callable $value_compare_function, array $array1, array ...$arrays): static
    {
        $arrays[] = $value_compare_function;
        return new self(array_uintersect($array1, ...$arrays));
    }

    /**
     * Computes the intersection of this array and other arrays with additional indexes using a user-defined comparison function.
     *
     * Alias of `array_uintersect_assoc`.
     *
     * @param callable $value_compare_function The comparison function.
     * @param array ...$array Arrays to compare against.
     * @return static Returns a new instance with the associative array intersection.
     */
    final public function get_custom_associative_intersection(callable $value_compare_function, array ...$array): static
    {
        $array[] = $value_compare_function;
        return new self(array_uintersect_assoc($this->value, ...$array));
    }

    /**
     * Computes the intersection of arrays with additional indexes using a user-defined comparison function.
     *
     * Static alias of `array_uintersect_assoc`.
     *
     * @param callable $value_compare_function The comparison function.
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to compare against.
     * @return static Returns a new instance with the associative array intersection.
     */
    final static public function uintersect_assoc(callable $value_compare_function, array $array1, array ...$arrays): static
    {
        $arrays[] = $value_compare_function;
        return new self(array_uintersect_assoc($array1, ...$arrays));
    }

    /**
     * Filters values of this array using a callback function.
     *
     * Alias of `array_filter`.
     *
     * @param callable $callback The callback function.
     * @return static Returns the instance after filtering values.
     */
    final public function filter_values(callable $callback): static
    {
        $this->value = array_filter($this->value, $callback);
        return $this;
    }

    /**
     * Filters keys of this array using a callback function.
     *
     * Alias of `array_filter` with mode `ARRAY_FILTER_USE_KEY`.
     *
     * @param callable $callback The callback function.
     * @return static Returns the instance after filtering keys.
     */
    final public function filter_keys(callable $callback): static
    {
        $this->value = array_filter($this->value, $callback, ARRAY_FILTER_USE_KEY);
        return $this;
    }

    /**
     * Filters keys and values of this array using a callback function.
     *
     * Alias of `array_filter` with mode `ARRAY_FILTER_USE_BOTH`.
     *
     * @param callable $callback The callback function.
     * @return static Returns the instance after filtering keys and values.
     */
    final public function filter_keys_and_values(callable $callback): static
    {
        $this->value = array_filter($this->value, $callback, ARRAY_FILTER_USE_BOTH);
        return $this;
    }

    /**
     * Filters the array using a callback function and returns a new instance.
     *
     * Static alias of `array_filter`.
     *
     * @param array $array The input array.
     * @param callable $callback The callback function.
     * @param int $mode Optional mode to specify which parameters are sent to the callback.
     * @return static Returns a new instance after filtering the array.
     */
    final static public function filter(array $array, callable $callback, int $mode = 0): static
    {
        return new self(array_filter($array, $callback, $mode));
    }

    /**
     * Flips the keys and values of this array.
     *
     * Alias of `array_flip`.
     *
     * @return static Returns the instance after flipping the array.
     */
    final public function flip(): static
    {
        $this->value = array_flip($this->value);
        return $this;
    }

    /**
     * Flips the keys and values of an array and returns a new instance.
     *
     * Static alias of `array_flip`.
     *
     * @param array $array The input array.
     * @return static Returns a new instance after flipping the array.
     */
    final static public function flip_array(array $array): static
    {
        return new self(array_flip($array));
    }

    /**
     * Merges one or more arrays into this array.
     *
     * Alias of `array_merge`.
     *
     * @param array ...$array Arrays to merge.
     * @return static Returns the instance after merging arrays.
     */
    final public function merge(array ...$array): static
    {
        $this->value = array_merge($this->value, ...$array);
        return $this;
    }

    /**
     * Merges arrays into this array while preserving numeric keys.
     *
     * Alias of `array_merge`.
     *
     * @param array ...$array Arrays to merge.
     * @return static Returns the instance after merging arrays.
     */
    final public function merge_preserve_numeric_keys(array ...$array): static
    {
        foreach ($array as $array) {
            $this->value = $this->value + $array;
        }
        return $this;
    }

    /**
     * Merges one or more arrays into a new instance.
     *
     * Static alias of `array_merge`.
     *
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to merge.
     * @return static Returns a new instance after merging arrays.
     */
    final static public function merge_arrays(array $array1, array ...$arrays): static
    {
        return new self(array_merge($array1, ...$arrays));
    }

    /**
     * Merges one or more arrays into this array recursively.
     *
     * Alias of `array_merge_recursive`.
     *
     * @param array ...$array Arrays to merge.
     * @return static Returns the instance after merging arrays.
     */
    final public function merge_recursive(array ...$array): static
    {
        $this->value = array_merge_recursive($this->value, ...$array);
        return $this;
    }

    /**
     * Merges one or more arrays recursively into a new instance.
     *
     * Static alias of `array_merge_recursive`.
     *
     * @param array $array1 The first array.
     * @param array ...$arrays Arrays to merge.
     * @return static Returns a new instance after merging arrays.
     */
    final static public function merge_arrays_recursive(array $array1, array ...$arrays): static
    {
        return new self(array_merge_recursive($array1, ...$arrays));
    }

    /**
     * Replaces values in this array with values from other arrays.
     *
     * Alias of `array_replace`.
     *
     * @param array ...$replacements Arrays containing replacements.
     * @return static Returns the instance after replacing values.
     */
    final public function replace_values(array ...$replacements): static
    {
        $this->value = array_replace($this->value, ...$replacements);
        return $this;
    }

    /**
     * Replaces values in an array with values from other arrays.
     *
     * Static alias of `array_replace`.
     *
     * @param array $array1 The array to be replaced.
     * @param array ...$replacements Arrays containing replacements.
     * @return static Returns a new instance after replacing values.
     */
    final static public function replace(array $array1, array ...$replacements): static
    {
        return new self(array_replace($array1, ...$replacements));
    }

    /**
     * Replaces values in this array recursively with values from other arrays.
     *
     * Alias of `array_replace_recursive`.
     *
     * @param array ...$replacements Arrays containing replacements.
     * @return static Returns the instance after replacing values recursively.
     */
    final public function replace_values_recursive(array ...$replacements): static
    {
        $this->value = array_replace_recursive($this->value, ...$replacements);
        return $this;
    }

    /**
     * Replaces values in an array recursively with values from other arrays.
     *
     * Static alias of `array_replace_recursive`.
     *
     * @param array $array1 The array to be replaced.
     * @param array ...$replacements Arrays containing replacements.
     * @return static Returns a new instance after replacing values recursively.
     */
    final static public function replace_recursive(array $array1, array ...$replacements): static
    {
        return new self(array_replace_recursive($array1, ...$replacements));
    }

    /**
     * Reverses the order of the elements in this array.
     *
     * Alias of `array_reverse`.
     *
     * @param bool $preserve_keys Whether to preserve keys. Defaults to `false`.
     * @return static Returns the instance after reversing order.
     */
    final public function reverse(bool $preserve_keys = false): static
    {
        $this->value = array_reverse($this->value, $preserve_keys);
        return $this;
    }

    /**
     * Reverses the order of the elements in an array.
     *
     * Static alias of `array_reverse`.
     *
     * @param array $array The input array.
     * @param bool $preserve_keys Whether to preserve keys. Defaults to `false`.
     * @return static Returns a new instance after reversing order.
     */
    final static public function reverse_array(array $array, bool $preserve_keys = false): static
    {
        return new self(array_reverse($array, $preserve_keys));
    }

    /**
     * Removes duplicate values from this array.
     *
     * Alias of `array_unique`.
     *
     * @param int $flags Optional flags to use. Defaults to `SORT_STRING`.
     * @return static Returns the instance after removing duplicates.
     */
    final public function remove_duplicates(int $flags = SORT_STRING): static
    {
        $this->value = array_unique($this->value, $flags);
        return $this;
    }

    /**
     * Removes duplicate values from an array.
     *
     * Static alias of `array_unique`.
     *
     * @param array $array The input array.
     * @param int $flags Optional flags to use. Defaults to `SORT_STRING`.
     * @return static Returns a new instance after removing duplicates.
     */
    final static public function unique(array $array, int $flags = SORT_STRING): static
    {
        return new self(array_unique($array, $flags));
    }

    /**
     * Returns all the keys of the array.
     *
     * Alias of `array_keys`.
     *
     * @param mixed $filter_value Optional value to filter keys.
     * @param bool $strict Optional flag for strict comparison. Defaults to `false`.
     * @return array Returns an array of keys.
     */
    final public function get_keys(mixed $filter_value = null, bool $strict = false): array
    {
        return array_keys($this->value, $filter_value, $strict);
    }

    /**
     * Returns all the keys of the specified array.
     *
     * Static alias of `array_keys`.
     *
     * @param array $array The input array.
     * @param mixed $filter_value Optional value to filter keys.
     * @param bool $strict Optional flag for strict comparison. Defaults to `false`.
     * @return array Returns an array of keys.
     */
    final static public function keys(array $array, mixed $filter_value = null, bool $strict = false): array
    {
        return array_keys($array, $filter_value, $strict);
    }

    /**
     * Checks if a key exists in this array.
     *
     * Alias of `array_key_exists`.
     *
     * @param int|string $key The key to check.
     * @return bool Returns `true` if the key exists, `false` otherwise.
     */
    final public function has_key(int|string $key): bool
    {
        return array_key_exists($key, $this->value);
    }

    /**
     * Checks if a key exists in the specified array.
     *
     * Static alias of `array_key_exists`.
     *
     * @param array $array The input array.
     * @param int|string $key The key to check.
     * @return bool Returns `true` if the key exists, `false` otherwise.
     */
    final static public function key_exists(array $array, int|string $key): bool
    {
        return array_key_exists($key, $array);
    }

    /**
     * Searches for a value in this array and returns its key.
     *
     * Alias of `array_search`.
     *
     * @param mixed $value The value to search for.
     * @param bool $strict Optional flag for strict comparison. Defaults to `false`.
     * @return int|string|false Returns the key if found, `false` otherwise.
     */
    final public function get_key(mixed $value, bool $strict = false): int|string|false
    {
        return array_search($value, $this->value, $strict);
    }

    /**
     * Searches for a value in an array and returns its key.
     *
     * Static alias of `array_search`.
     *
     * @param array $array The input array.
     * @param mixed $value The value to search for.
     * @param bool $strict Optional flag for strict comparison. Defaults to `false`.
     * @return int|string|false Returns the key if found, `false` otherwise.
     */
    final static public function search(array $array, mixed $value, bool $strict = false): int|string|false
    {
        return array_search($value, $array, $strict);
    }

    /**
     * Applies a callback function to every element of this array.
     *
     * Alias of `array_walk`.
     *
     * @param callable $function The callback function.
     * @param mixed $args Optional additional arguments to pass to the callback.
     * @return static Returns the instance after walking the array.
     */
    final public function walk(callable $function, mixed $args = null): static
    {
        array_walk($this->value, $function, $args);
        return $this;
    }

    /**
     * Applies a callback function to every element of an array.
     *
     * Static alias of `array_walk`.
     *
     * @param array &$array The input array.
     * @param callable $function The callback function.
     * @param mixed $args Optional additional arguments to pass to the callback.
     * @return static Returns a new instance after walking the array.
     */
    final static public function walk_array(array &$array, callable $function, mixed $args = null): static
    {
        array_walk($array, $function, $args);
        return new self($array);
    }

    /**
     * Applies a callback function recursively to every element of this array.
     *
     * Alias of `array_walk_recursive`.
     *
     * @param callable $function The callback function.
     * @param mixed $args Optional additional arguments to pass to the callback.
     * @return static Returns the instance after walking the array recursively.
     */
    final public function walk_recursive(callable $function, mixed $args = null): static
    {
        array_walk_recursive($this->value, $function, $args);
        return $this;
    }

    /**
     * Applies a callback function recursively to every element of an array.
     *
     * Static alias of `array_walk_recursive`.
     *
     * @param array &$array The input array.
     * @param callable $function The callback function.
     * @param mixed $args Optional additional arguments to pass to the callback.
     * @return static Returns a new instance after walking the array recursively.
     */
    final static public function walk_recursive_array(array &$array, callable $function, mixed $args = null): static
    {
        array_walk_recursive($array, $function, $args);
        return new self($array);
    }

    /**
     * Sorts this array in ascending order.
     *
     * Alias of `sort` and `asort`.
     *
     * @param bool $maintain_keys Whether to maintain keys. Defaults to `true`.
     * @param int $flags Optional flags for sorting. Defaults to `SORT_REGULAR`.
     * @return static Returns the instance after sorting in ascending order.
     */
    final public function sort_ascending(bool $maintain_keys = true, int $flags = SORT_REGULAR): static
    {
        if ($maintain_keys) {
            asort($this->value, $flags);
        } else {
            sort($this->value, $flags);
        }
        return $this;
    }

    final public function custom_value_sort(callable $compare_function, bool $maintain_keys = false): static
    {
        if ($maintain_keys) {
            $this->value = usort($this->array, $compare_function);
        } else {
            $this->value = uasort($this->array, $compare_function);
        }
        return $this;
    }

    final public static function usort(array &$array, callable $callback): static
    {
        return new self(usort($array, $callback));
    }

    final public function custom_key_sort(callable $compare_function): static
    {
        $this->value = usort($this->array, $compare_function);
        return $this;
    }

    /**
     * Sorts this array in descending order.
     *
     * Alias of `rsort` and `arsort`.
     *
     * @param bool $maintain_keys Whether to maintain keys. Defaults to `true`.
     * @param int $flags Optional flags for sorting. Defaults to `SORT_REGULAR`.
     * @return static Returns the instance after sorting in descending order.
     */
    final public function sort_descending(bool $maintain_keys = true, int $flags = SORT_REGULAR): static
    {
        if ($maintain_keys) {
            arsort($this->value, $flags);
        } else {
            rsort($this->value, $flags);
        }
        return $this;
    }

    /**
     * Sorts the specified array in ascending order.
     *
     * Static alias of `sort` and `asort`.
     *
     * @param array $array The input array.
     * @param bool $maintain_keys Whether to maintain keys. Defaults to `true`.
     * @param int $flags Optional flags for sorting. Defaults to `SORT_REGULAR`.
     * @return static Returns a new instance after sorting in ascending order.
     */
    final static public function sort(array $array, bool $maintain_keys = true, int $flags = SORT_REGULAR): static
    {
        if ($maintain_keys) {
            asort($array, $flags);
        } else {
            sort($array, $flags);
        }
        return new self($array);
    }

    /**
     * Sorts the specified array in descending order.
     *
     * Static alias of `rsort` and `arsort`.
     *
     * @param array $array The input array.
     * @param bool $maintain_keys Whether to maintain keys. Defaults to `true`.
     * @param int $flags Optional flags for sorting. Defaults to `SORT_REGULAR`.
     * @return static Returns a new instance after sorting in descending order.
     */
    final static public function rsort(array $array, bool $maintain_keys = true, int $flags = SORT_REGULAR): static
    {
        if ($maintain_keys) {
            arsort($array, $flags);
        } else {
            rsort($array, $flags);
        }
        return new self($array);
    }

    /**
     * Sorts this array by key in ascending order.
     *
     * Alias of `ksort`.
     *
     * @param int $flags Optional flags for sorting. Defaults to `SORT_REGULAR`.
     * @return static Returns the instance after sorting by key in ascending order.
     */
    final public function sort_key_ascending(int $flags = SORT_REGULAR): static
    {
        ksort($this->value, $flags);
        return $this;
    }

    /**
     * Sorts the specified array by key in ascending order.
     *
     * Static alias of `ksort`.
     *
     * @param array $array The input array.
     * @param int $flags Optional flags for sorting. Defaults to `SORT_REGULAR`.
     * @return static Returns a new instance after sorting by key in ascending order.
     */
    final static public function ksort(array $array, int $flags = SORT_REGULAR): static
    {
        ksort($array, $flags);
        return new self($array);
    }

    /**
     * Sorts this array by key in descending order.
     *
     * Alias of `krsort`.
     *
     * @param int $flags Optional flags for sorting. Defaults to `SORT_REGULAR`.
     * @return static Returns the instance after sorting by key in descending order.
     */
    final public function sort_key_descending(int $flags = SORT_REGULAR): static
    {
        krsort($this->value, $flags);
        return $this;
    }

    /**
     * Sorts the specified array by key in descending order.
     *
     * Static alias of `krsort`.
     *
     * @param array $array The input array.
     * @param int $flags Optional flags for sorting. Defaults to `SORT_REGULAR`.
     * @return static Returns a new instance after sorting by key in descending order.
     */
    final static public function krsort(array $array, int $flags = SORT_REGULAR): static
    {
        krsort($array, $flags);
        return new self($array);
    }

    /**
     * Sorts this array in natural order.
     *
     * Alias of `natsort`.
     *
     * @param bool $case_sensitive Whether to perform case-sensitive sorting. Defaults to `false`.
     * @return static Returns the instance after sorting in natural order.
     */
    final public function sort_natural(bool $case_sensitive = false): static
    {
        if ($case_sensitive) {
            natsort($this->value);
        } else {
            natcasesort($this->value);
        }
        return $this;
    }


    /**
     * Sorts the specified array in natural order.
     *
     * Static alias of `natsort`.
     *
     * @param array $array The input array.
     * @param bool $case_sensitive Whether to perform case-sensitive sorting. Defaults to `false`.
     * @return static Returns a new instance after sorting in natural order.
     */
    final static public function natsort(array $array, bool $case_sensitive = false): static
    {
        if ($case_sensitive) {
            natsort($array);
        } else {
            natcasesort($array);
        }
        return new self($array);
    }

    /**
     * Creates an array containing variables and their values.
     *
     * Static alias of `compact`.
     *
     * @param array|string $var_name The variable name(s) to include in the array.
     * @param array|string ...$var_names Additional variable names to include.
     * @return static Returns a new instance with the created array.
     */
    final public static function compact(array|string $var_name, array|string ...$var_names): static
    {
        return new self(compact($var_name, ...$var_names));
    }

    /**
     * Randomly shuffles the elements of this array.
     *
     * Alias of `shuffle`.
     *
     * @return static Returns the instance after shuffling the array.
     */
    final public function shuffle(): static
    {
        shuffle($this->value);
        return $this;
    }

    /**
     * Randomly shuffles the elements of an array.
     *
     * Static alias of `shuffle`.
     *
     * @param array $array The input array.
     * @return static Returns a new instance after shuffling the array.
     */
    final static public function shuffle_array(array $array): static
    {
        shuffle($array);
        return new self($array);
    }

    final public static function explode(string $string, string $separator, int $limit = PHP_INT_MAX): static
    {
        return new self(explode($separator, $string, $limit));
    }

    final public function implode(string $separator = ""): string
    {
        return implode($separator, $this->value);
    }

    public function get_first_key(): int|string|null
    {
        return array_key_first($this->value);
    }
    public function get_first_element(): mixed
    {
        if ($key = $this->get_first_key()) {
            return $this->value[$key];
        }
        throw new \ValueError('empty array.');
    }
    public function get_last_key(): int|string|null
    {
        return array_key_last($this->value);
    }
    public function get_last_element(): mixed
    {
        if ($key = $this->get_last_key()) {
            return $this->value[$key];
        }
        throw new \ValueError('empty array.');
    }
}


/* FILE: ./Types/ArrayExtensions/MultilineStringArray.php */

<?php

namespace PHP_Library\Types\ArrayExtension;

use PHP_Library\Types\ArrayType;
use PHP_Library\Types\StringType;

class MultilineStringArray extends ArrayType
{

    public function __construct(string|StringType $multiline_string)
    {
        $array_of_strings = ArrayType::explode($multiline_string, PHP_EOL);
        $this->value = $array_of_strings->walk(function ($value) {
            $value = new StringType($value);
        })->get_built_in_type();
    }

    /**
     * Get the longest line from the current string.
     *
     * @return StringType
     */
    public function get_longest_line(): StringType
    {
        return ArrayType::usort($this->value, function (StringType $a, StringType $b) {
            return $a->get_length() <=> $b->get_length();
        })->get_first_element();
    }

    /**
     * Append a string as a new line to the current string.
     *
     * @param string|StringType $string The string to append as a new line.
     *
     * @return StringType
     */
    public function append(string|StringType $string): static
    {
        $this->push(StringType::make($string));
        return $this;
    }

    /**
     * Add left padding to each line of the current string.
     *
     * @param int $padding The amount of left padding to add.
     * @param int $top_offset [optional] The number of lines to skip before adding padding.
     *
     * @return StringType
     */
    public function padding_left(int $padding = 1, int $top_offset = 0): static
    {
        return $this->walk(function (StringType $string, int $line) use ($padding, $top_offset) {
            if ($line > $top_offset) $string->pad_left($padding);
        });
    }

    /**
     * Add right padding to each line of the current string.
     *
     * @param int $padding The amount of right padding to add.
     * @param int $top_offset [optional] The number of lines to skip before adding padding.
     *
     * @return StringType
     */
    public function padding_right(int $padding = 1, int $top_offset = 0): static
    {
        return $this->walk(function (StringType $string, int $line) use ($padding, $top_offset) {
            if ($line > $top_offset) $string->pad_left($padding);
        });
    }
}


/* FILE: ./Types/AbstractType.php */

<?php

namespace  PHP_Library\Types;

abstract class AbstractType
{

    protected $value;

    /**
     * Constructor for TypeWrap.
     *
     * @param mixed $value The value to wrap with a custom type.
     */
    abstract public function __construct($value);

    /**
     * Convert the custom type to a string representation.
     *
     * @return string
     */
    public function __toString(): string
    {
        return var_export($this->value);
    }

    /**
     * Get the type of the custom type.
     *
     * @return string
     */
    public function get_type(): string
    {
        return ($type = gettype($this->value)) === 'object' ? get_class($this->value) : $type;
    }

    /**
     * Check if the custom type is of a specific type or class.
     *
     * @param string $type_or_class The type or class name to check against.
     * @return bool
     */
    public function is(string $type_or_class): bool
    {
        return ($type_or_class == $this->get_type());
    }

    /**
     * Check if the variable is empty
     *
     * @return bool
     */
    public function is_empty(): bool
    {
        return empty($this->value);
    }

    public function get_built_in_type(): mixed
    {
        return $this->value;
    }

    public static function convert(mixed &$mixed): static
    {
        return $mixed = new static($mixed);
    }
}


/* FILE: ./Types/ArrayType.php */

<?php

namespace  PHP_Library\Types;

use PHP_Library\Types\BaseTypeTraits\PHPArrayFunctions;

/**
 * ArrayType represents a class for handling array values.
 *
 * @package TypeWrap
 */
class ArrayType extends AbstractType implements \Iterator, \ArrayAccess, \Countable
{
    use PHPArrayFunctions;
    /**
     * Constructor to initialize the ArrayType with a given array value.
     *
     * @param mixed $value The initial array value.
     */
    public function __construct(mixed ...$value)
    {
        if (count($value) === 1 && key_exists(0, $value) && is_array($value[0])) {

            $this->value = $value[0];
        } else {
            $this->value = $value;
        }
    }

    public function offsetExists($offset): bool
    {
        return isset($this->value[$offset]);
    }

    public function offsetUnset($offset): void
    {
        unset($this->value[$offset]);
    }

    public function offsetGet($offset): mixed
    {
        return isset($this->value[$offset]) ? $this->value[$offset] : null;
    }

    public function offsetSet(mixed $offset, mixed $value): void
    {
        if (is_null($offset)) {
            $this->value[] = $value;
        } else {
            $this->value[$offset] = $value;
        }
    }

    public function rewind(): void
    {
        reset($this->value);
    }
    public function reset(): void
    {
        reset($this->value);
    }
    public function current(): mixed
    {
        return current($this->value);
    }
    public function key(): mixed
    {
        return key($this->value);
    }
    public function next(): void
    {
        next($this->value);
    }
    public function valid(): bool
    {
        return key($this->value) !== null;
    }

    public function serialize()
    {
        return serialize($this->value);
    }
    public function unserialize($data)
    {
        $this->value = unserialize($data);
    }

    public function count(): int
    {
        return count($this->value);
    }

    /**
     * Move the value associated with one key to another key in the array.
     *
     * @param int|string $from_key The source key to move the value from.
     * @param int|string $to_key The destination key to move the value to.
     * @return static The modified ArrayType.
     */
    public function move_value(int|string $from_key, int|string $to_key): static
    {
        $this->value[$to_key] = $this->value[$from_key];
        unset($this->value['from_key']);
        return $this;
    }

    /**
     * Convert the array to its string representation with formatting.
     *
     * @return string The formatted string representation of the array.
     */
    public function __toString(): string
    {
        /* title */
        $title = new StringType("Array(" . count($this->value) . ")");
        if (count($this->value) === 0) {
            return $title;
        }

        /* keys formatieren und laenge vom laengsten key suchen */
        $longest_key_string_length = 0;
        foreach ($this->value as $key => $value) {
            $key = new StringType($key);
            if ($key->is('string')) {
                $key->surround("'");
            }
            if (($length = $key->get_length()) > $longest_key_string_length) {
                $longest_key_string_length = $length;
            }
        }

        $string = new StringType();
        foreach ($this->value as $key => $value) {
            $seperator = new StringType("\xE2\x95\x90");
            $key = new StringType($key);
            if ($key->is('string')) {
                $key->surround("'");
            }
            $seperator->repeat(
                ($longest_key_string_length + 1)
                    - $key->get_length()
            );
            if (is_object($value) && get_class($value) === 'Closure') {
                $string->append("$key $seperator> Closure" . PHP_EOL);
            } else {
                $value = new StringType((string) AbstractType::construct($value));
                if (is_string($value->value)) {
                    $value = new StringType((string)$value);
                    $string_length = $value->get_length();
                    $value->replace(PHP_EOL, '¶' . PHP_EOL)->word_wrap(80)->surround('`')->append("($string_length)");
                } else {
                    $value = new StringType((string) $value);
                }
                if ($value->has_linebreak()) {
                    $value->padding_left($longest_key_string_length + 1, 1);
                }
                $string->append_line("$key $seperator> $value");
            }
        }
        if (isset($GLOBALS["DEBUG_PRINT"])) {
            $string->box_around_string(1, $title);
        }
        return $string;
    }
}


/* FILE: ./Types/ObjectType.php */

<?php

namespace  PHP_Library\Types;

use Traversable;
use ArrayIterator;

/**
 * ObjectType represents an object manipulation class designed to provide common operations on objects.
 * It allows checking and accessing object properties, converting objects to strings, and more.
 *
 * @package TypeWrap
 */
class ObjectType extends TypeWrap implements \IteratorAggregate
{
    /**
     * Constructor.
     *
     * @param mixed $value The initial object to wrap.
     */
    public function __construct(mixed $value)
    {
        $this->value = $value;
    }

    /**
     * Check if a property exists on the wrapped object.
     *
     * @param int|string $property The property to check.
     * @return bool True if the property exists, false otherwise.
     */
    public function is_set(int|string $property): bool
    {
        return isset($this->value->$property);
    }

    /**
     * Get the value of this wrapped object property.
     *
     * @param int|string $property The property to retrieve.
     * @return mixed The value of the property.
     */
    public function get(int|string $property): mixed
    {
        if ($this->is_set($property)) {
            return $this->value->$property;
        }
    }

    /**
     * Get the class name of the wrapped object.
     *
     * @return StringType The class name as a StringType.
     */
    public function get_class_name(): StringType
    {
        return new StringType(get_class($this->value));
    }

    /**
     * Set the value of an object property.
     *
     * @param int|string $property The property to set.
     * @param mixed $value The value to assign to the property.
     * @return ObjectType This ObjectType instance.
     */
    public function set(int|string $property, mixed $value): ObjectType
    {
        if ($this->is_set($property)) {
            $this->value->$property = $value;
        }
        return $this;
    }

    /**
     * Convert the object to a string representation.
     *
     * @return string The object properties as a string.
     */
    public function __toString(): string
    {
        $class_name = $this->get_class_name();
        $show_scope = true;

        $string = new StringType();
        $properties = get_mangled_object_vars($this->value);
        if (empty($properties)) {
            $empty = new StringType('empty');
            return $empty->format_italic();
        }
        foreach ($properties as $property => $value) {
            $property_name = new StringType($property);
            $property_name->remove_null_characters();
            if ($property_name->is_starting_with($class_name)) {
                $scope = 'private';
                $property_name->remove_string_at_start($class_name);
            } else if ($property_name->is_starting_with("*")) {
                $scope = 'protected';
                $property_name->remove_string_at_start("*");
            } else {
                $scope = 'public';
            }
            $string->append_line($show_scope
                ? "-($scope)->$property_name = "
                : "->$property_name = ");
        }

        /* append line of second column to each line */
        $longest_line_length = $string->get_longest_line()->get_length();
        $indexed_properties = array_keys($properties);
        $output = new StringType();
        foreach ($string->get_lines() as $i => $line) {
            $property = $indexed_properties[$i];
            $value = AbstractType::construct($properties[$property]);
            if (is_string($value->value)) {
                $value = new StringType((string)$value);
                $string_length = $value->get_length();
                $value->replace(PHP_EOL, '¶' . PHP_EOL)->word_wrap(80)->surround('`')->append("($string_length)");
            } else {
                $value = new StringType((string) $value);
            }


            if ($value->has_linebreak()) {
                $value->padding_left($longest_line_length, 1);
            }

            $output->append_line(
                $line->padding_right(
                    $longest_line_length - $line->get_length()
                )->append($value)
            );
        }
        if (isset($GLOBALS["DEBUG_PRINT"])) {
            $output->box_around_string(1, $class_name);
        }
        return $output->value;
    }

    /**
     * Get an iterator for the object properties.
     *
     * @return Traversable An iterator for the object properties.
     */
    public function getIterator(): Traversable
    {
        return new ArrayIterator($this->value);
    }
}


/* FILE: ./AjaxHandler/AjaxHandler.php */

<?php

namespace AjaxHandler;

use AjaxHandler\DataValidator\DataValidator;

class AjaxHandler
{
    public DataValidator $validator;

    protected array $actions;

    final public function __construct(?array $post_data = null)
    {
        $this->validator = new DataValidator($post_data ? $post_data : $_POST);
    }

    public function add_action(callable $function, bool $only_on_success = true): static
    {
        array_push($this->actions, ['only_on_success' => $only_on_success, 'function' => $function]);
        return $this;
    }

    public function send_response(): static
    {
        if ($errors = $this->validator->get_errors()) {
            $this->send_bad_response($errors);
        }
        return $this->send_good_response();
    }

    private function send_good_response(): static
    {
        foreach ($this->actions as $action) {
            call_user_func($action['function']);
        }
        return $this;
    }

    private function send_bad_response($errors): static
    {
        http_response_code(400);
        foreach ($this->actions as $action) {
            if ($action['only_on_success']) {
                continue;
            }
            call_user_func($action['function']);
        }
        echo json_encode(['errors' => $errors]);
        return $this;
    }
}


/* FILE: ./AjaxHandler/DataValidator/DataValidator.php */

<?php

namespace AjaxHandler\DataValidator;

class DataValidator
{
    protected array $errors;

    protected array $keys_to_check;

    private array $data;

    public function __construct(array $data)
    {
        $this->data = $data;
    }

    function has_value(string|int ...$key): static
    {
        foreach ($key as $key) {
            if (empty($this->data[$key])) {
                array_push($this->errors, new Error($key, "Data for '{$key}' does not exist"));
            }
        }
        return $this;
    }

    function preg_match_value(string|int $key, string $pattern, string $error_message): static
    {
        if (!preg_match($pattern, $this->data[$key])) {
            array_push($this->errors, new Error($key, $error_message));
        }
        return $this;
    }

    function filter_var_value(string|int $key, int $filter, string $error_message): static
    {
        if (!filter_var($this->data[$key], $filter)) {
            array_push($this->errors, new Error($key, $error_message));
        }
        return $this;
    }

    /**
     * @return Error[]
     */
    public function get_errors(): array
    {
        return $this->errors;
    }
}


/* FILE: ./AjaxHandler/DataValidator/Error.php */

<?php

namespace AjaxHandler\DataValidator;

class Error
{
    public readonly string $id;

    public readonly string $message;

    final public function __construct(string $id, string $message)
    {
        $this->id = $id;
        $this->message = $message;
    }
}


/* FILE: ./index.php */

<?php

use PHP_Library\Router\Endpoint;

include 'include_me.php';

$index = Endpoint::new_text_file_endpoint('/', 'text.html');
$redirect = Endpoint::new_redirect_endpoint('/redirect', $index);


/* FILE: ./System/Directory.php */

<?php

namespace  PHP_Library\System;

class Directory implements \Iterator
{
    public string $name;
    public string $path;
    protected array $files = [];
    protected array $folders = [];
    private bool $was_read = false;

    public static function open(string $path = '.'): self
    {
        $dir = new Directory($path, null);
        return $dir->read();
    }

    public function __construct(string $path, ?int $permissions = 0777)
    {
        $path = realpath($path);
        if (!$path) {
            throw new \Error("'{$path}' is not a valid path name.");
        }

        $this->path = $path;
        $this->name = pathinfo($path, PATHINFO_BASENAME);
        if ($permissions) {
            $this->mkdir(
                permissions: $permissions,
                throw_error: false
            );
        }
    }

    public function mkdir(int $permissions = 0777, bool $recursive = false, bool $throw_error = true): self
    {
        if (!@mkdir($this->path, $permissions, $recursive) && $throw_error) {
            throw new \Error("Could not create {$this->path}");
        }
        return $this;
    }

    public function get_size(): float
    {
        return (float) exec("du -s -m " . $this->path);
    }

    public function read(): static
    {
        foreach (glob($this->path . "/*") as $item_name) {
            if ($item_name == '.' || $item_name == '..') {
                continue;
            }
            $this->add_item($item_name);
        }
        $this->was_read = true;
        return $this;
    }

    /**
     * Find pathnames matching a pattern
     *
     * @return FileHandle[]
     */
    public function glob($pattern): array
    {
        if (is_int(strpos($pattern, DIRECTORY_SEPARATOR))) {
            throw new \Error("No sub directories!");
        }
        if (!$this->was_read) {
            $files = glob($this->path . '/' . $pattern);
            $this->add_item(...$files);
        }
        return $this->glob_items($pattern);
    }

    /**
     * get_files()
     *
     * @return FileHandle[]
     */
    public function get_files(): array
    {
        return $this->files;
    }

    public function __toString(): string
    {
        return $this->path;
    }

    public function rewind(): void
    {
        reset($this->files);
    }

    public function current(): mixed
    {
        return current($this->files);
    }
    public function key(): mixed
    {
        return key($this->files);
    }
    public function next(): void
    {
        next($this->files);
    }
    public function valid(): bool
    {
        return key($this->files) !== null;
    }

    protected function glob_items($pattern): array
    {
        $matches = [];
        foreach ($this->files as $file_name => $file) {
            if (fnmatch($pattern, $file_name)) {
                $matches[$file_name] = $file;
            }
        }
        foreach ($this->folders as $folder_name => $folder) {
            if (fnmatch($pattern, $folder_name)) {
                $matches[$folder_name] = $folder;
            }
        }
        return $matches;
    }

    protected function add_item(string|FileHandle|Directory ...$item): static
    {
        foreach ($item as $item) {
            if (is_string($item)) {
                $item = static::create_item($item);
            }
            if ($item instanceof FileHandle) {
                $this->files[$item->name] = $item;
            }
            if ($item instanceof Directory) {
                $this->folders[$item->name] = $item;
            }
        }
        return $this;
    }

    protected static function create_item($path): FileHandle|Directory
    {
        if (is_file($path)) {
            return new FileHandle($path);
        } else if (is_dir($path)) {
            return Directory::open($path);
        }
    }

    public function delete_content(): static
    {
        foreach ($this->files as $file) {
            unlink($file);
        }
        foreach ($this->folders as $folder) {
            unlink($folder);
        }
        return $this;
    }
}


/* FILE: ./System/ProgramHandle.php */

<?php

namespace  PHP_Library\System;

use PHP_Library\Notices\Notice;
use PHP_Library\Notices\Warning;


/**
 * ProgramHandleInterface defines the interface for creating and executing shell commands.
 */
interface ProgramHandleInterface
{
    public function add_option(string $flag, string $argument, string $name): ProgramHandle;
    public function set_source_files(string $file_pattern, string $input_flag): ProgramHandle;
    public function set_destination_file(string $file_name): ProgramHandle;
    public function execute(): ProgramHandle;
    public function get_execute(): string;
}


/**
 * ProgramHandle represents a class for creating and executing shell commands.
 */
class ProgramHandle implements ProgramHandleInterface
{
    protected array $sources;
    protected array $destiantion;
    protected array $options = [];

    public ?string $result_line = null;
    public ?array $full_output = null;
    public ?int $result_code = null;
    protected ?ProgramHandle $pipe_to = null;

    public function __construct(public ?string $command = null)
    {
    }

    /**
     * Set the source file(s) based on a glob pattern and an input flag.
     *
     * @param string $file_pattern The glob pattern for source files.
     * @param string $input_flag The input flag for the source files.
     * @return static The modified ProgramHandle instance.
     */
    public function set_source_files(string $file_pattern, string $source_flag = 'i'): static
    {
        $files = glob($file_pattern);
        if (is_array($files)) {
            if (count($files) > 0) {
                $cleaned_files = array_map(function ($file) {
                    return realpath($file);
                }, $files);
                $this->add_option(
                    group: "sources",
                    flag: $source_flag,
                    argument: $cleaned_files
                );
                $this->sources = $files;
            } else {
                Notice::trigger("No files in '$file_pattern'");
            }
        } else {
            Warning::trigger("Invalid glob-pattern: '$file_pattern'");
        }
        return $this;
    }

    /**
     * Set the source.
     *
     * @param string $source.
     * @param string $input_flag The input flag for the source.
     * @return static The modified ProgramHandle instance.
     */
    public function set_source(string $source, string $source_flag = ''): static
    {
        $this->add_option(
            group: "sources",
            flag: $source_flag,
            argument: $source
        );
        $this->sources[0] = $source;

        return $this;
    }

    /**
     * Set the destination file for the command.
     *
     * @param string $filename The destination filename.
     * @return static The modified ProgramHandle instance.
     */
    public function set_destination_file(string $filename, string $destination_flag = ''): static
    {
        $this->add_option(
            group: "destination",
            flag: $destination_flag,
            argument: $filename
        );
        return $this;
    }

    /**
     * Add an option to the command.
     *
     * @param string $flag The flag for the option.
     * @param string|array $argument The argument for the option.
     * @param string|null $name The name of the option.
     * @return static The modified ProgramHandle instance.
     */

    public function add_option(string $flag = '', string|array $argument = '', ?string $group = null): static
    {
        if (!$flag && !$argument) {
            return $this;
        }
        if ($flag) {
            if (strpos($flag, '-',) !== 0) {
                $flag = (strlen($flag) >= 2) ? "--$flag" : "-$flag";
            }
        }
        $option = '';

        if (is_array($argument)) {
            foreach ($argument as $value) {
                $option .= "$flag \"$value\" ";
            }
        } elseif (is_string($argument)) {
            $option = "$flag \"$argument\"";
        }

        if ($group) {
            $this->options[$group] = trim("$option");
        } else {
            array_push($this->options, $option);
        }

        return $this;
    }

    /**
     * Add an option with a dynamic value generated by a callback function.
     *
     * @param string $flag The flag for the option.
     * @param callable $value_callback The callback function to generate the option value.
     *                                The function should accept the current ProgramHandle instance and return a string.
     * @return static The modified ProgramHandle instance.
     */
    public function add_dynamic_option(string $flag = '', callable $callback): static
    {
        $reflection = new \ReflectionFunction($callback);
        if ($reflection->getReturnType() != 'string') {
            throw new \Error("Callback function does not return a string.");
        }

        if (
            count($reflection->getParameters()) != 1
            || $reflection->getParameters()[0]->getType() != get_class($this)
        ) {
            throw new \Error("Callback function should have only one parameter of type 'ProgramHandle', but it is '" . $reflection->getParameters()[0]->getType() . "'.");
        }

        $option = call_user_func($callback, $this);
        $this->add_option($flag, $option);
        return $this;
    }

    /**
     * Get the complete command string to execute.
     *
     * @return string The command string.
     */
    public function get_execute_string(): string
    {
        if ($this->pipe_to) {
            $this->pipe_to->get_execute_string();
        }

        if (isset($this->options['sources'])) {
            $sources_option = $this->options['sources'];
            unset($this->options['sources']);
            $this->options['sources'] = $sources_option;
        }
        if (isset($this->options['destination'])) {
            $destination_option = $this->options['destination'];
            unset($this->options['destination']);
            $this->options['destination'] = $destination_option;
        }

        return implode(
            " ",
            [
                $this->command,
                implode(" ",                $this->options)
            ]
        );
    }

    /**
     * Execute the command and capture the result.
     *
     * @return static The modified ProgramHandle instance.
     */
    public function execute(): static
    {
        $this->result_line = exec(
            command: $this->get_execute_string(),
            output: $this->full_output,
            result_code: $this->result_code
        );
        return $this;
    }

    public function pipe(): ProgramHandle
    {
        $pipe = new ProgramHandle(); // Create a new instance of ProgramHandle for the next command in the pipeline.
        $this->pipe_to = $pipe;
        return $pipe;
    }

    /**
     * Get array of registred source / input files
     *
     * @return string The command string.
     */
    public function get_source_files(): array
    {
        return $this->sources;
    }

    /**
     * Get the result of the executed command.
     *
     * @return string The result of the executed command.
     */
    public function get_execute(): string
    {
        if (!$this->result_line) {
            $this->execute();
        }
        return $this->result_line;
    }
}


/* FILE: ./System/FileHandle.php */

<?php

namespace  PHP_Library\System;

use PHP_Library\Error\Warning;

class FileHandle
{
    public string $path;
    public string $name;

    private bool $use_lock_file;
    private string $lock_file_path;

    private mixed $file_handle = null;
    private mixed $memory = null;

    public function __construct(string $path, bool $use_lock_file = true)
    {
        $this->path = file_exists($path) ? realpath($path) : $path;
        $this->name = pathinfo($path, PATHINFO_BASENAME);
        if ($this->use_lock_file = $use_lock_file) {
            $this->lock_file_path = $this->path . '.lock';
        }
    }

    public function __destruct()
    {
        if ($this->file_handle) {
            $this->close_file();
        }
    }

    public function __toString()
    {
        return $this->path;
    }

    public function open_file(string $fopen_mode = 'r', bool $load_file = true, int $microseconds_freq = 100, int $timeout_seconds = 1): FileHandle
    {
        if ($this->use_lock_file) {
            if (!is_writable($this->path)) {
                throw new \Error("Can't write to '{$this->path} as '" . posix_getpwuid(posix_geteuid())['name'] . "'");
            }
            $start_time = microtime(true);
            while (!@mkdir($this->lock_file_path)) {
                usleep($microseconds_freq);
                // Check if the time limit has been exceeded
                if ((microtime(true) - $start_time) >= $timeout_seconds) {
                    throw new \Error("Timeout exceeded: File was locked from different process for more than {$timeout_seconds} seconds.");
                }
            }
        }
        if (!$this->file_handle = fopen($this->path, $fopen_mode)) {
            Warning::trigger("Could not fopen(filename: '{$this->path}', mode: '$fopen_mode').");
            $this->close_file();
        }
        if ($load_file) {
            $this->memory = unserialize(
                data: stream_get_contents($this->file_handle),
                options: []
            );
        }
        return $this;
    }

    public function close_file(): FileHandle
    {
        if (get_resource_type($this->file_handle) == 'stream') {
            fclose($this->file_handle);
        }
        if ($this->use_lock_file) {
            @rmdir($this->lock_file_path);
        }
        return $this;
    }

    public function write_file(mixed $data): FileHandle
    {
        rewind($this->file_handle);
        ftruncate($this->file_handle, 0);
        if (!fwrite($this->file_handle, serialize($data))) {
            $type = get_resource_type($this->file_handle);
            Warning::trigger("Could not fwrite($type, \$data).");
        }
        $this->memory = $data;
        return $this;
    }

    public function create_file(bool $force = false): FileHandle
    {
        if ($force) {
            $stream = fopen($this->path, 'w');
        } else {
            $stream = @fopen($this->path, 'x');
        }
        if ($stream) {
            fclose($stream);
        }
        return $this;
    }

    public function get_memory()
    {
        return $this->memory;
    }

    public function get_change_time(): int
    {
        return filectime($this);
    }

    public function get_last_access_time(): int
    {
        return fileatime($this);
    }

    public function get_modification_time(): int
    {
        return filemtime($this);
    }
}


/* FILE: ./Settings/Settings.php */

<?php

namespace  PHP_Library\Settings;


/**
 * Settings
 *
 * get Setting values from setting.ini file with Settings::get('section_name/key'). keys of the section [settings] can be accessed with 'key' directly.
 */
class Settings
{
    public static array $settings = [];
    private static bool $initialized = false;
    protected static $file_name = 'settings.ini';
    protected static string $main_section = 'settings';
    protected static array $template = [
        'settings' => [],
    ];

    /**
     * Echo the value of 'section/key'
     *
     * @param string $key key can be 'key' to access values of the section [settings] or 'section/key' to access values of other sections.
     * @param bool [optional] $strict if true, the method throws an error when the 'section/key' is not found.
     *
     * @return void
     */
    public static function echo(string $key, bool $strict = false): void
    {
        echo self::get(
            key: $key,
            strict: $strict
        );
    }

    /**
     * Get the value of 'section/key'
     *
     * @param string $key key can be 'key' to access values of the section [settings] or 'section/key' to access values of other sections.
     * @param bool $strict if true, the method throws an error when the 'section/key' is not found.
     *
     * @return mixed
     */
    public static function get(string $key, ?string $type_or_class = null, $strict = false): mixed
    {
        self::initialize();
        $section = self::$main_section;
        $key = self::get_section_key($key, $section);
        $setting_value = self::get_settings_value($section, $key, $strict);
        if ($type_or_class) {
            return self::cast_value($type_or_class, $setting_value);
        }
        return $setting_value;
    }

    /**
     * Register a Settings key-value pair
     *
     * @param string $key The 'key' or 'section/key' that should be added to the settings.ini file
     * @param null|bool|float|int|string [optional] $default the default value of that setting.
     *
     * @return bool true on success, false if settings already set.
     */
    public static function register(string $key, null|bool|float|int|string $default = ''): bool
    {
        self::initialize();

        if (strpbrk($key, '{}|&~![()^"')) {
            throw new \Error("'$key' must not contain any of this characters: {}|&~![()\"");
        }

        if (is_string($default)) {
            $default = self::escape_characters($default);
        }

        $section = self::$main_section;
        $key = self::get_section_key($key, $section);

        if (!isset(self::$settings[$section])) {
            self::$settings[$section] = [];
        }

        if (!isset(self::$settings[$section][$key])) {
            self::$settings[$section][$key] = $default;
            self::write_current_settings_to_ini();
            return true;
        }
        return false;
    }

    /**
     * Creates settings.ini if not existing yet and loads the Content of settings.ini statically into Settings Class and sets self::$initialized.
     *
     * @return void
     */
    private static function initialize(): void
    {
        if (self::$initialized) {
            return;
        }
        if (!file_exists(filename: self::$file_name,)) {
            self::touch_ini();
        }
        self::load();
        self::$initialized = true;
    }

    /**
     * Creates settings.ini file from array self::$template .
     * If settings.ini already exists, it will overwrite it.
     *
     * @return void
     */
    protected static function touch_ini(): void
    {
        self::write_ini(self::$template);
    }

    /**
     * Creates settings.ini file from current array self::$settings.
     * If settings.ini already exists, it will overwrite it.
     *
     * @return void
     */
    protected static function write_current_settings_to_ini(): void
    {
        self::write_ini(self::$settings);
    }

    /**
     * Creates settings.ini file from array $content array.
     * If settings.ini already exists, it will overwrite it.
     *
     * @param array $content The array of Settings. ['section' => ['key' => 'value'] ]
     *
     * @return void
     */
    private static function write_ini(array $content): void
    {
        $class = new \ReflectionClass(get_called_class());
        $comment_string = trim(preg_replace(
            [
                '/(\/\*\*| *\*\/$|^ *\*)/m',
                '/\n\n/m'
            ],
            [
                '',
                PHP_EOL
            ],
            $class->getDocComment()
        ));
        $settings_ini_content = '';
        foreach (explode(PHP_EOL, $comment_string) as $line) {
            $settings_ini_content .= "; " . trim($line) . PHP_EOL;
        }
        $settings_ini_content .= PHP_EOL;

        foreach ($content as $section_key => $section_items) {
            $settings_ini_content .= "[$section_key]" . PHP_EOL;
            foreach ($section_items as $key => $value) {
                switch ($type = gettype($value)) {
                    case 'boolean':
                        $value = $value ? 'true' : 'false';
                        break;

                    case 'NULL':
                        $value = 'null';
                        break;

                    case 'string':
                        $value = '"' . self::escape_characters($value) . '"';
                        break;

                    case 'integer':
                    case 'double':
                        // No modification needed for these types
                        break;

                    default:
                        throw new \Error("Unsupported type: " . $type);
                }
                $settings_ini_content .= "{$key}={$value}" . PHP_EOL;
            }
            $settings_ini_content .= PHP_EOL;
        }
        if (file_put_contents(
            filename: self::$file_name,
            data: $settings_ini_content
        ) === false) {
            throw new \Error("Could not write data to '" . self::$file_name . "'");
        }
    }

    /**
     * Loads the settings.ini file.
     *
     * @return void
     */
    protected static function load(): void
    {
        self::$settings = parse_ini_file(
            filename: self::$file_name,
            process_sections: true,
            scanner_mode: INI_SCANNER_TYPED
        );
    }

    /**
     * Escapes character of a string to get used as ini value.
     *
     * @param string $string [explicite description]
     *
     * @return string
     */
    private static function escape_characters(string $string): string
    {
        return addcslashes($string, "\\\'\"\0\t\r\n;#=:");
    }

    /**
     *
     * @param string $key access subsections with 'section/key' or 'key' to acces main-section
     *
     * @return string
     */
    private static function get_section_key(string $key, &$section): string
    {
        $section_and_key = explode('/', $key, 2);
        switch (count($section_and_key)) {
            case 1:
                return $section_and_key[0];
            case 2:
                $section = $section_and_key[0];
                return $section_and_key[1];
            default:
                throw new \Error("'$key' is an invalid key.");
        }
    }

    private static function get_settings_value(string $section, string $key, bool $strict): mixed
    {
        if (!isset(self::$settings[$section])) {
            if ($strict) throw new \Error("Setting section [{$section}] was not found.");
            return null;
        }
        if (!isset(self::$settings[$section][$key])) {
            if ($strict) throw new \Error("Setting {$key} in [{$section}] was not found.");
            return null;
        }

        return self::$settings[$section][$key];
    }

    private static function cast_value(string $type_or_class, mixed $value): mixed
    {
        if (class_exists($type_or_class)) {
            return new $type_or_class($value);
        } elseif (settype($value, $type_or_class)) {
        } else {
            throw new \Error("'{$type_or_class}' is not a type or class.");
        }
        return $value;
    }
}
